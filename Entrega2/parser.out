Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC
Rule 2     auxprogram -> vars auxprogram
Rule 3     auxprogram -> function auxprogram
Rule 4     auxprogram -> empty
Rule 5     array -> ID LFTBRACSQR exp RGTBRACSQR
Rule 6     arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR
Rule 7     arrayvaluesaux -> constant
Rule 8     arrayvaluesaux -> constant COMMA arrayvaluesaux
Rule 9     assignment -> assignmentaux EQUAL expression SEMICOLON
Rule 10    assignmentaux -> ID
Rule 11    assignmentaux -> array
Rule 12    blockreturn -> LFTBRAC blockneutral RGTBRAC
Rule 13    blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC
Rule 14    blockneutral -> statement blockneutral
Rule 15    blockneutral -> vars blockneutral
Rule 16    blockneutral -> empty
Rule 17    block -> LFTBRAC blockneutral RGTBRAC
Rule 18    condition -> IF conditionaux
Rule 19    condition -> IF conditionaux ELSE block
Rule 20    conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2
Rule 21    conditionaux2 -> ELSEIF conditionaux
Rule 22    conditionaux2 -> empty
Rule 23    constant -> ID
Rule 24    constant -> array
Rule 25    constant -> cteN
Rule 26    constant -> cteS
Rule 27    constant -> TRUE
Rule 28    constant -> FALSE
Rule 29    constant -> call2
Rule 30    cteN -> FLOAT
Rule 31    cteN -> INT
Rule 32    cteS -> STRING
Rule 33    exp -> term expaux
Rule 34    expaux -> PLUS exp expaux
Rule 35    expaux -> MINUS exp expaux
Rule 36    expaux -> empty
Rule 37    factor -> LFTPAREN expression RGTPAREN
Rule 38    factor -> constant
Rule 39    factor -> MINUS constant
Rule 40    factor -> PLUS constant
Rule 41    expression -> exp
Rule 42    expression -> exp expressionaux exp
Rule 43    expressionaux -> AND
Rule 44    expressionaux -> DOUBEQUAL
Rule 45    expressionaux -> NOT
Rule 46    expressionaux -> OR
Rule 47    expressionaux -> LESSTHANEQUAL
Rule 48    expressionaux -> GREATTHANEQUAL
Rule 49    expressionaux -> GREATTHAN
Rule 50    expressionaux -> LESSTHAN
Rule 51    loop -> WHILE LFTPAREN expression RGTPAREN block
Rule 52    write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON
Rule 53    parameter -> type ID codeAddParameters
Rule 54    parameter -> type ID codeAddParameters COMMA parameter
Rule 55    parameter -> empty
Rule 56    term -> factor termaux
Rule 57    termaux -> MULTIPLICATION term termaux
Rule 58    termaux -> DIVISION term termaux
Rule 59    termaux -> empty
Rule 60    statement -> assignment
Rule 61    statement -> condition
Rule 62    statement -> loop
Rule 63    statement -> write
Rule 64    statement -> read
Rule 65    statement -> call
Rule 66    type -> INT checkType
Rule 67    type -> FLOAT checkType
Rule 68    type -> CHAR checkType
Rule 69    type -> BOOL checkType
Rule 70    type -> STRING checkType
Rule 71    main -> PRIOMH codeScope block
Rule 72    function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
Rule 73    functionaux -> VOID codeTypeVoid checkType
Rule 74    functionaux -> funcIndicator type
Rule 75    vars -> type varsaux
Rule 76    varsaux -> ID codeAddVar EQUAL expression SEMICOLON
Rule 77    varsaux -> ID codeAddVar EQUAL expression COMMA varsaux
Rule 78    varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
Rule 79    varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux
Rule 80    call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON
Rule 81    callaux -> COMMA exp callaux
Rule 82    callaux -> empty
Rule 83    call2 -> ID LFTPAREN exp callaux RGTPAREN
Rule 84    read -> READ LFTPAREN readaux RGTPAREN SEMICOLON
Rule 85    readaux -> ID
Rule 86    readaux -> array
Rule 87    empty -> <empty>
Rule 88    codeScope -> <empty>
Rule 89    checkType -> <empty>
Rule 90    codeAddVar -> <empty>
Rule 91    codeAddVarArreglo -> <empty>
Rule 92    codeAddParameters -> <empty>
Rule 93    codeNameOfFunct -> <empty>
Rule 94    codeTypeVoid -> <empty>
Rule 95    funcIndicator -> <empty>

Terminals, with rules where they appear

AND                  : 43
BOOL                 : 69
CHAR                 : 68
COMMA                : 8 54 77 79 81
DIVISION             : 58
DOUBEQUAL            : 44
ELSE                 : 19
ELSEIF               : 21
EQUAL                : 9 76 77 78 79
FALSE                : 28
FLOAT                : 30 67
FUNCTION             : 72
GREATTHAN            : 49
GREATTHANEQUAL       : 48
ID                   : 1 5 10 23 53 54 72 76 77 78 79 80 83 85
IF                   : 18 19
INT                  : 31 66 78 79
LESSTHAN             : 50
LESSTHANEQUAL        : 47
LFTBRAC              : 1 12 13 17
LFTBRACSQR           : 5 6 78 79
LFTPAREN             : 20 37 51 52 72 80 83 84
MINUS                : 35 39
MULTIPLICATION       : 57
NOT                  : 45
OR                   : 46
PLUS                 : 34 40
PRINT                : 52
PRIOMH               : 71
PROGRAM              : 1
READ                 : 84
RETURN               : 13
RGTBRAC              : 1 12 13 17
RGTBRACSQR           : 5 6 78 79
RGTPAREN             : 20 37 51 52 72 80 83 84
SEMICOLON            : 9 13 52 76 78 80 84
STRING               : 32 70
TRUE                 : 27
VOID                 : 73
WHILE                : 51
error                : 

Nonterminals, with rules where they appear

array                : 11 24 86
arrayvalues          : 78 79
arrayvaluesaux       : 6 8
assignment           : 60
assignmentaux        : 9
auxprogram           : 1 2 3
block                : 19 20 51 71
blockneutral         : 12 13 14 15 17
blockreturn          : 72
call                 : 65
call2                : 29
callaux              : 80 81 83
checkType            : 66 67 68 69 70 73
codeAddParameters    : 53 54
codeAddVar           : 76 77
codeAddVarArreglo    : 78 79
codeNameOfFunct      : 72
codeScope            : 71 72 72
codeTypeVoid         : 73
condition            : 61
conditionaux         : 18 19 21
conditionaux2        : 20
constant             : 7 8 38 39 40 52
cteN                 : 25
cteS                 : 26
empty                : 4 16 22 36 55 59 82
exp                  : 5 13 34 35 41 42 42 80 81 83
expaux               : 33 34 35
expression           : 9 20 37 51 76 77
expressionaux        : 42
factor               : 56
funcIndicator        : 74
function             : 3
functionaux          : 72
loop                 : 62
main                 : 1
parameter            : 54 72
program              : 0
read                 : 64
readaux              : 84
statement            : 14
term                 : 33 57 58
termaux              : 56 57 58
type                 : 53 54 74 75
vars                 : 2 15
varsaux              : 75 77 79
write                : 63

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID LFTBRAC auxprogram main RGTBRAC

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID LFTBRAC auxprogram main RGTBRAC

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . LFTBRAC auxprogram main RGTBRAC

    LFTBRAC         shift and go to state 4


state 4

    (1) program -> PROGRAM ID LFTBRAC . auxprogram main RGTBRAC
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (75) vars -> . type varsaux
    (72) function -> . FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
    (87) empty -> .
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 87 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    function                       shift and go to state 10
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 8
    type                           shift and go to state 13
    empty                          shift and go to state 9

state 5

    (72) function -> FUNCTION . codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
    (88) codeScope -> .

    VOID            reduce using rule 88 (codeScope -> .)
    INT             reduce using rule 88 (codeScope -> .)
    FLOAT           reduce using rule 88 (codeScope -> .)
    CHAR            reduce using rule 88 (codeScope -> .)
    BOOL            reduce using rule 88 (codeScope -> .)
    STRING          reduce using rule 88 (codeScope -> .)

    codeScope                      shift and go to state 16

state 6

    (2) auxprogram -> vars . auxprogram
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (75) vars -> . type varsaux
    (72) function -> . FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
    (87) empty -> .
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 87 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    function                       shift and go to state 10
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 17
    type                           shift and go to state 13
    empty                          shift and go to state 9

state 7

    (68) type -> CHAR . checkType
    (89) checkType -> .

    ID              reduce using rule 89 (checkType -> .)

    checkType                      shift and go to state 18

state 8

    (1) program -> PROGRAM ID LFTBRAC auxprogram . main RGTBRAC
    (71) main -> . PRIOMH codeScope block

    PRIOMH          shift and go to state 19

    main                           shift and go to state 20

state 9

    (4) auxprogram -> empty .

    PRIOMH          reduce using rule 4 (auxprogram -> empty .)


state 10

    (3) auxprogram -> function . auxprogram
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (75) vars -> . type varsaux
    (72) function -> . FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
    (87) empty -> .
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 87 (empty -> .)
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    function                       shift and go to state 10
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 21
    type                           shift and go to state 13
    empty                          shift and go to state 9

state 11

    (70) type -> STRING . checkType
    (89) checkType -> .

    ID              reduce using rule 89 (checkType -> .)

    checkType                      shift and go to state 22

state 12

    (66) type -> INT . checkType
    (89) checkType -> .

    ID              reduce using rule 89 (checkType -> .)

    checkType                      shift and go to state 23

state 13

    (75) vars -> type . varsaux
    (76) varsaux -> . ID codeAddVar EQUAL expression SEMICOLON
    (77) varsaux -> . ID codeAddVar EQUAL expression COMMA varsaux
    (78) varsaux -> . ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> . ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux

    ID              shift and go to state 24

    varsaux                        shift and go to state 25

state 14

    (67) type -> FLOAT . checkType
    (89) checkType -> .

    ID              reduce using rule 89 (checkType -> .)

    checkType                      shift and go to state 26

state 15

    (69) type -> BOOL . checkType
    (89) checkType -> .

    ID              reduce using rule 89 (checkType -> .)

    checkType                      shift and go to state 27

state 16

    (72) function -> FUNCTION codeScope . functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
    (73) functionaux -> . VOID codeTypeVoid checkType
    (74) functionaux -> . funcIndicator type
    (95) funcIndicator -> .

    VOID            shift and go to state 30
    INT             reduce using rule 95 (funcIndicator -> .)
    FLOAT           reduce using rule 95 (funcIndicator -> .)
    CHAR            reduce using rule 95 (funcIndicator -> .)
    BOOL            reduce using rule 95 (funcIndicator -> .)
    STRING          reduce using rule 95 (funcIndicator -> .)

    functionaux                    shift and go to state 28
    funcIndicator                  shift and go to state 29

state 17

    (2) auxprogram -> vars auxprogram .

    PRIOMH          reduce using rule 2 (auxprogram -> vars auxprogram .)


state 18

    (68) type -> CHAR checkType .

    ID              reduce using rule 68 (type -> CHAR checkType .)


state 19

    (71) main -> PRIOMH . codeScope block
    (88) codeScope -> .

    LFTBRAC         reduce using rule 88 (codeScope -> .)

    codeScope                      shift and go to state 31

state 20

    (1) program -> PROGRAM ID LFTBRAC auxprogram main . RGTBRAC

    RGTBRAC         shift and go to state 32


state 21

    (3) auxprogram -> function auxprogram .

    PRIOMH          reduce using rule 3 (auxprogram -> function auxprogram .)


state 22

    (70) type -> STRING checkType .

    ID              reduce using rule 70 (type -> STRING checkType .)


state 23

    (66) type -> INT checkType .

    ID              reduce using rule 66 (type -> INT checkType .)


state 24

    (76) varsaux -> ID . codeAddVar EQUAL expression SEMICOLON
    (77) varsaux -> ID . codeAddVar EQUAL expression COMMA varsaux
    (78) varsaux -> ID . codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> ID . codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux
    (90) codeAddVar -> .
    (91) codeAddVarArreglo -> .

    EQUAL           reduce using rule 90 (codeAddVar -> .)
    LFTBRACSQR      reduce using rule 91 (codeAddVarArreglo -> .)

    codeAddVarArreglo              shift and go to state 33
    codeAddVar                     shift and go to state 34

state 25

    (75) vars -> type varsaux .

    IF              reduce using rule 75 (vars -> type varsaux .)
    WHILE           reduce using rule 75 (vars -> type varsaux .)
    PRINT           reduce using rule 75 (vars -> type varsaux .)
    READ            reduce using rule 75 (vars -> type varsaux .)
    ID              reduce using rule 75 (vars -> type varsaux .)
    INT             reduce using rule 75 (vars -> type varsaux .)
    FLOAT           reduce using rule 75 (vars -> type varsaux .)
    CHAR            reduce using rule 75 (vars -> type varsaux .)
    BOOL            reduce using rule 75 (vars -> type varsaux .)
    STRING          reduce using rule 75 (vars -> type varsaux .)
    RGTBRAC         reduce using rule 75 (vars -> type varsaux .)
    RETURN          reduce using rule 75 (vars -> type varsaux .)
    FUNCTION        reduce using rule 75 (vars -> type varsaux .)
    PRIOMH          reduce using rule 75 (vars -> type varsaux .)


state 26

    (67) type -> FLOAT checkType .

    ID              reduce using rule 67 (type -> FLOAT checkType .)


state 27

    (69) type -> BOOL checkType .

    ID              reduce using rule 69 (type -> BOOL checkType .)


state 28

    (72) function -> FUNCTION codeScope functionaux . ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope

    ID              shift and go to state 35


state 29

    (74) functionaux -> funcIndicator . type
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    type                           shift and go to state 36

state 30

    (73) functionaux -> VOID . codeTypeVoid checkType
    (94) codeTypeVoid -> .

    ID              reduce using rule 94 (codeTypeVoid -> .)

    codeTypeVoid                   shift and go to state 37

state 31

    (71) main -> PRIOMH codeScope . block
    (17) block -> . LFTBRAC blockneutral RGTBRAC

    LFTBRAC         shift and go to state 38

    block                          shift and go to state 39

state 32

    (1) program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC .

    $end            reduce using rule 1 (program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC .)


state 33

    (78) varsaux -> ID codeAddVarArreglo . LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> ID codeAddVarArreglo . LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux

    LFTBRACSQR      shift and go to state 40


state 34

    (76) varsaux -> ID codeAddVar . EQUAL expression SEMICOLON
    (77) varsaux -> ID codeAddVar . EQUAL expression COMMA varsaux

    EQUAL           shift and go to state 41


state 35

    (72) function -> FUNCTION codeScope functionaux ID . codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope
    (93) codeNameOfFunct -> .

    LFTPAREN        reduce using rule 93 (codeNameOfFunct -> .)

    codeNameOfFunct                shift and go to state 42

state 36

    (74) functionaux -> funcIndicator type .

    ID              reduce using rule 74 (functionaux -> funcIndicator type .)


state 37

    (73) functionaux -> VOID codeTypeVoid . checkType
    (89) checkType -> .

    ID              reduce using rule 89 (checkType -> .)

    checkType                      shift and go to state 43

state 38

    (17) block -> LFTBRAC . blockneutral RGTBRAC
    (14) blockneutral -> . statement blockneutral
    (15) blockneutral -> . vars blockneutral
    (16) blockneutral -> . empty
    (60) statement -> . assignment
    (61) statement -> . condition
    (62) statement -> . loop
    (63) statement -> . write
    (64) statement -> . read
    (65) statement -> . call
    (75) vars -> . type varsaux
    (87) empty -> .
    (9) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (18) condition -> . IF conditionaux
    (19) condition -> . IF conditionaux ELSE block
    (51) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (52) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN readaux RGTPAREN SEMICOLON
    (80) call -> . ID LFTPAREN exp callaux RGTPAREN SEMICOLON
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType
    (10) assignmentaux -> . ID
    (11) assignmentaux -> . array
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 87 (empty -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 46
    PRINT           shift and go to state 47
    READ            shift and go to state 45
    ID              shift and go to state 56
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    vars                           shift and go to state 44
    array                          shift and go to state 48
    write                          shift and go to state 49
    call                           shift and go to state 51
    statement                      shift and go to state 52
    type                           shift and go to state 13
    empty                          shift and go to state 53
    read                           shift and go to state 50
    assignment                     shift and go to state 54
    assignmentaux                  shift and go to state 55
    condition                      shift and go to state 57
    blockneutral                   shift and go to state 59
    loop                           shift and go to state 60

state 39

    (71) main -> PRIOMH codeScope block .

    RGTBRAC         reduce using rule 71 (main -> PRIOMH codeScope block .)


state 40

    (78) varsaux -> ID codeAddVarArreglo LFTBRACSQR . INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR . INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux

    INT             shift and go to state 61


state 41

    (76) varsaux -> ID codeAddVar EQUAL . expression SEMICOLON
    (77) varsaux -> ID codeAddVar EQUAL . expression COMMA varsaux
    (41) expression -> . exp
    (42) expression -> . exp expressionaux exp
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    term                           shift and go to state 74
    constant                       shift and go to state 62
    cteS                           shift and go to state 63
    cteN                           shift and go to state 65
    call2                          shift and go to state 67
    exp                            shift and go to state 78
    factor                         shift and go to state 69
    array                          shift and go to state 64
    expression                     shift and go to state 79

state 42

    (72) function -> FUNCTION codeScope functionaux ID codeNameOfFunct . LFTPAREN parameter RGTPAREN blockreturn codeScope

    LFTPAREN        shift and go to state 80


state 43

    (73) functionaux -> VOID codeTypeVoid checkType .

    ID              reduce using rule 73 (functionaux -> VOID codeTypeVoid checkType .)


state 44

    (15) blockneutral -> vars . blockneutral
    (14) blockneutral -> . statement blockneutral
    (15) blockneutral -> . vars blockneutral
    (16) blockneutral -> . empty
    (60) statement -> . assignment
    (61) statement -> . condition
    (62) statement -> . loop
    (63) statement -> . write
    (64) statement -> . read
    (65) statement -> . call
    (75) vars -> . type varsaux
    (87) empty -> .
    (9) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (18) condition -> . IF conditionaux
    (19) condition -> . IF conditionaux ELSE block
    (51) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (52) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN readaux RGTPAREN SEMICOLON
    (80) call -> . ID LFTPAREN exp callaux RGTPAREN SEMICOLON
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType
    (10) assignmentaux -> . ID
    (11) assignmentaux -> . array
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 87 (empty -> .)
    RETURN          reduce using rule 87 (empty -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 46
    PRINT           shift and go to state 47
    READ            shift and go to state 45
    ID              shift and go to state 56
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    vars                           shift and go to state 44
    array                          shift and go to state 48
    write                          shift and go to state 49
    call                           shift and go to state 51
    statement                      shift and go to state 52
    type                           shift and go to state 13
    empty                          shift and go to state 53
    read                           shift and go to state 50
    assignment                     shift and go to state 54
    assignmentaux                  shift and go to state 55
    condition                      shift and go to state 57
    blockneutral                   shift and go to state 81
    loop                           shift and go to state 60

state 45

    (84) read -> READ . LFTPAREN readaux RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 82


state 46

    (51) loop -> WHILE . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 83


state 47

    (52) write -> PRINT . LFTPAREN constant RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 84


state 48

    (11) assignmentaux -> array .

    EQUAL           reduce using rule 11 (assignmentaux -> array .)


state 49

    (63) statement -> write .

    IF              reduce using rule 63 (statement -> write .)
    WHILE           reduce using rule 63 (statement -> write .)
    PRINT           reduce using rule 63 (statement -> write .)
    READ            reduce using rule 63 (statement -> write .)
    ID              reduce using rule 63 (statement -> write .)
    INT             reduce using rule 63 (statement -> write .)
    FLOAT           reduce using rule 63 (statement -> write .)
    CHAR            reduce using rule 63 (statement -> write .)
    BOOL            reduce using rule 63 (statement -> write .)
    STRING          reduce using rule 63 (statement -> write .)
    RGTBRAC         reduce using rule 63 (statement -> write .)
    RETURN          reduce using rule 63 (statement -> write .)


state 50

    (64) statement -> read .

    IF              reduce using rule 64 (statement -> read .)
    WHILE           reduce using rule 64 (statement -> read .)
    PRINT           reduce using rule 64 (statement -> read .)
    READ            reduce using rule 64 (statement -> read .)
    ID              reduce using rule 64 (statement -> read .)
    INT             reduce using rule 64 (statement -> read .)
    FLOAT           reduce using rule 64 (statement -> read .)
    CHAR            reduce using rule 64 (statement -> read .)
    BOOL            reduce using rule 64 (statement -> read .)
    STRING          reduce using rule 64 (statement -> read .)
    RGTBRAC         reduce using rule 64 (statement -> read .)
    RETURN          reduce using rule 64 (statement -> read .)


state 51

    (65) statement -> call .

    IF              reduce using rule 65 (statement -> call .)
    WHILE           reduce using rule 65 (statement -> call .)
    PRINT           reduce using rule 65 (statement -> call .)
    READ            reduce using rule 65 (statement -> call .)
    ID              reduce using rule 65 (statement -> call .)
    INT             reduce using rule 65 (statement -> call .)
    FLOAT           reduce using rule 65 (statement -> call .)
    CHAR            reduce using rule 65 (statement -> call .)
    BOOL            reduce using rule 65 (statement -> call .)
    STRING          reduce using rule 65 (statement -> call .)
    RGTBRAC         reduce using rule 65 (statement -> call .)
    RETURN          reduce using rule 65 (statement -> call .)


state 52

    (14) blockneutral -> statement . blockneutral
    (14) blockneutral -> . statement blockneutral
    (15) blockneutral -> . vars blockneutral
    (16) blockneutral -> . empty
    (60) statement -> . assignment
    (61) statement -> . condition
    (62) statement -> . loop
    (63) statement -> . write
    (64) statement -> . read
    (65) statement -> . call
    (75) vars -> . type varsaux
    (87) empty -> .
    (9) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (18) condition -> . IF conditionaux
    (19) condition -> . IF conditionaux ELSE block
    (51) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (52) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN readaux RGTPAREN SEMICOLON
    (80) call -> . ID LFTPAREN exp callaux RGTPAREN SEMICOLON
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType
    (10) assignmentaux -> . ID
    (11) assignmentaux -> . array
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 87 (empty -> .)
    RETURN          reduce using rule 87 (empty -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 46
    PRINT           shift and go to state 47
    READ            shift and go to state 45
    ID              shift and go to state 56
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    vars                           shift and go to state 44
    array                          shift and go to state 48
    write                          shift and go to state 49
    call                           shift and go to state 51
    statement                      shift and go to state 52
    type                           shift and go to state 13
    empty                          shift and go to state 53
    read                           shift and go to state 50
    assignment                     shift and go to state 54
    assignmentaux                  shift and go to state 55
    condition                      shift and go to state 57
    blockneutral                   shift and go to state 85
    loop                           shift and go to state 60

state 53

    (16) blockneutral -> empty .

    RGTBRAC         reduce using rule 16 (blockneutral -> empty .)
    RETURN          reduce using rule 16 (blockneutral -> empty .)


state 54

    (60) statement -> assignment .

    IF              reduce using rule 60 (statement -> assignment .)
    WHILE           reduce using rule 60 (statement -> assignment .)
    PRINT           reduce using rule 60 (statement -> assignment .)
    READ            reduce using rule 60 (statement -> assignment .)
    ID              reduce using rule 60 (statement -> assignment .)
    INT             reduce using rule 60 (statement -> assignment .)
    FLOAT           reduce using rule 60 (statement -> assignment .)
    CHAR            reduce using rule 60 (statement -> assignment .)
    BOOL            reduce using rule 60 (statement -> assignment .)
    STRING          reduce using rule 60 (statement -> assignment .)
    RGTBRAC         reduce using rule 60 (statement -> assignment .)
    RETURN          reduce using rule 60 (statement -> assignment .)


state 55

    (9) assignment -> assignmentaux . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 86


state 56

    (80) call -> ID . LFTPAREN exp callaux RGTPAREN SEMICOLON
    (10) assignmentaux -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR

    LFTPAREN        shift and go to state 87
    EQUAL           reduce using rule 10 (assignmentaux -> ID .)
    LFTBRACSQR      shift and go to state 88


state 57

    (61) statement -> condition .

    IF              reduce using rule 61 (statement -> condition .)
    WHILE           reduce using rule 61 (statement -> condition .)
    PRINT           reduce using rule 61 (statement -> condition .)
    READ            reduce using rule 61 (statement -> condition .)
    ID              reduce using rule 61 (statement -> condition .)
    INT             reduce using rule 61 (statement -> condition .)
    FLOAT           reduce using rule 61 (statement -> condition .)
    CHAR            reduce using rule 61 (statement -> condition .)
    BOOL            reduce using rule 61 (statement -> condition .)
    STRING          reduce using rule 61 (statement -> condition .)
    RGTBRAC         reduce using rule 61 (statement -> condition .)
    RETURN          reduce using rule 61 (statement -> condition .)


state 58

    (18) condition -> IF . conditionaux
    (19) condition -> IF . conditionaux ELSE block
    (20) conditionaux -> . LFTPAREN expression RGTPAREN block conditionaux2

    LFTPAREN        shift and go to state 89

    conditionaux                   shift and go to state 90

state 59

    (17) block -> LFTBRAC blockneutral . RGTBRAC

    RGTBRAC         shift and go to state 91


state 60

    (62) statement -> loop .

    IF              reduce using rule 62 (statement -> loop .)
    WHILE           reduce using rule 62 (statement -> loop .)
    PRINT           reduce using rule 62 (statement -> loop .)
    READ            reduce using rule 62 (statement -> loop .)
    ID              reduce using rule 62 (statement -> loop .)
    INT             reduce using rule 62 (statement -> loop .)
    FLOAT           reduce using rule 62 (statement -> loop .)
    CHAR            reduce using rule 62 (statement -> loop .)
    BOOL            reduce using rule 62 (statement -> loop .)
    STRING          reduce using rule 62 (statement -> loop .)
    RGTBRAC         reduce using rule 62 (statement -> loop .)
    RETURN          reduce using rule 62 (statement -> loop .)


state 61

    (78) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT . RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT . RGTBRACSQR EQUAL arrayvalues COMMA varsaux

    RGTBRACSQR      shift and go to state 92


state 62

    (38) factor -> constant .

    MULTIPLICATION  reduce using rule 38 (factor -> constant .)
    DIVISION        reduce using rule 38 (factor -> constant .)
    PLUS            reduce using rule 38 (factor -> constant .)
    MINUS           reduce using rule 38 (factor -> constant .)
    RGTBRACSQR      reduce using rule 38 (factor -> constant .)
    COMMA           reduce using rule 38 (factor -> constant .)
    RGTPAREN        reduce using rule 38 (factor -> constant .)
    SEMICOLON       reduce using rule 38 (factor -> constant .)
    AND             reduce using rule 38 (factor -> constant .)
    DOUBEQUAL       reduce using rule 38 (factor -> constant .)
    NOT             reduce using rule 38 (factor -> constant .)
    OR              reduce using rule 38 (factor -> constant .)
    LESSTHANEQUAL   reduce using rule 38 (factor -> constant .)
    GREATTHANEQUAL  reduce using rule 38 (factor -> constant .)
    GREATTHAN       reduce using rule 38 (factor -> constant .)
    LESSTHAN        reduce using rule 38 (factor -> constant .)


state 63

    (26) constant -> cteS .

    MULTIPLICATION  reduce using rule 26 (constant -> cteS .)
    DIVISION        reduce using rule 26 (constant -> cteS .)
    PLUS            reduce using rule 26 (constant -> cteS .)
    MINUS           reduce using rule 26 (constant -> cteS .)
    COMMA           reduce using rule 26 (constant -> cteS .)
    RGTPAREN        reduce using rule 26 (constant -> cteS .)
    RGTBRACSQR      reduce using rule 26 (constant -> cteS .)
    AND             reduce using rule 26 (constant -> cteS .)
    DOUBEQUAL       reduce using rule 26 (constant -> cteS .)
    NOT             reduce using rule 26 (constant -> cteS .)
    OR              reduce using rule 26 (constant -> cteS .)
    LESSTHANEQUAL   reduce using rule 26 (constant -> cteS .)
    GREATTHANEQUAL  reduce using rule 26 (constant -> cteS .)
    GREATTHAN       reduce using rule 26 (constant -> cteS .)
    LESSTHAN        reduce using rule 26 (constant -> cteS .)
    SEMICOLON       reduce using rule 26 (constant -> cteS .)


state 64

    (24) constant -> array .

    MULTIPLICATION  reduce using rule 24 (constant -> array .)
    DIVISION        reduce using rule 24 (constant -> array .)
    PLUS            reduce using rule 24 (constant -> array .)
    MINUS           reduce using rule 24 (constant -> array .)
    COMMA           reduce using rule 24 (constant -> array .)
    RGTPAREN        reduce using rule 24 (constant -> array .)
    RGTBRACSQR      reduce using rule 24 (constant -> array .)
    AND             reduce using rule 24 (constant -> array .)
    DOUBEQUAL       reduce using rule 24 (constant -> array .)
    NOT             reduce using rule 24 (constant -> array .)
    OR              reduce using rule 24 (constant -> array .)
    LESSTHANEQUAL   reduce using rule 24 (constant -> array .)
    GREATTHANEQUAL  reduce using rule 24 (constant -> array .)
    GREATTHAN       reduce using rule 24 (constant -> array .)
    LESSTHAN        reduce using rule 24 (constant -> array .)
    SEMICOLON       reduce using rule 24 (constant -> array .)


state 65

    (25) constant -> cteN .

    MULTIPLICATION  reduce using rule 25 (constant -> cteN .)
    DIVISION        reduce using rule 25 (constant -> cteN .)
    PLUS            reduce using rule 25 (constant -> cteN .)
    MINUS           reduce using rule 25 (constant -> cteN .)
    COMMA           reduce using rule 25 (constant -> cteN .)
    RGTPAREN        reduce using rule 25 (constant -> cteN .)
    RGTBRACSQR      reduce using rule 25 (constant -> cteN .)
    AND             reduce using rule 25 (constant -> cteN .)
    DOUBEQUAL       reduce using rule 25 (constant -> cteN .)
    NOT             reduce using rule 25 (constant -> cteN .)
    OR              reduce using rule 25 (constant -> cteN .)
    LESSTHANEQUAL   reduce using rule 25 (constant -> cteN .)
    GREATTHANEQUAL  reduce using rule 25 (constant -> cteN .)
    GREATTHAN       reduce using rule 25 (constant -> cteN .)
    LESSTHAN        reduce using rule 25 (constant -> cteN .)
    SEMICOLON       reduce using rule 25 (constant -> cteN .)


state 66

    (39) factor -> MINUS . constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    constant                       shift and go to state 93
    call2                          shift and go to state 67
    array                          shift and go to state 64
    cteN                           shift and go to state 65

state 67

    (29) constant -> call2 .

    MULTIPLICATION  reduce using rule 29 (constant -> call2 .)
    DIVISION        reduce using rule 29 (constant -> call2 .)
    PLUS            reduce using rule 29 (constant -> call2 .)
    MINUS           reduce using rule 29 (constant -> call2 .)
    COMMA           reduce using rule 29 (constant -> call2 .)
    RGTPAREN        reduce using rule 29 (constant -> call2 .)
    RGTBRACSQR      reduce using rule 29 (constant -> call2 .)
    AND             reduce using rule 29 (constant -> call2 .)
    DOUBEQUAL       reduce using rule 29 (constant -> call2 .)
    NOT             reduce using rule 29 (constant -> call2 .)
    OR              reduce using rule 29 (constant -> call2 .)
    LESSTHANEQUAL   reduce using rule 29 (constant -> call2 .)
    GREATTHANEQUAL  reduce using rule 29 (constant -> call2 .)
    GREATTHAN       reduce using rule 29 (constant -> call2 .)
    LESSTHAN        reduce using rule 29 (constant -> call2 .)
    SEMICOLON       reduce using rule 29 (constant -> call2 .)


state 68

    (27) constant -> TRUE .

    MULTIPLICATION  reduce using rule 27 (constant -> TRUE .)
    DIVISION        reduce using rule 27 (constant -> TRUE .)
    PLUS            reduce using rule 27 (constant -> TRUE .)
    MINUS           reduce using rule 27 (constant -> TRUE .)
    COMMA           reduce using rule 27 (constant -> TRUE .)
    RGTPAREN        reduce using rule 27 (constant -> TRUE .)
    RGTBRACSQR      reduce using rule 27 (constant -> TRUE .)
    AND             reduce using rule 27 (constant -> TRUE .)
    DOUBEQUAL       reduce using rule 27 (constant -> TRUE .)
    NOT             reduce using rule 27 (constant -> TRUE .)
    OR              reduce using rule 27 (constant -> TRUE .)
    LESSTHANEQUAL   reduce using rule 27 (constant -> TRUE .)
    GREATTHANEQUAL  reduce using rule 27 (constant -> TRUE .)
    GREATTHAN       reduce using rule 27 (constant -> TRUE .)
    LESSTHAN        reduce using rule 27 (constant -> TRUE .)
    SEMICOLON       reduce using rule 27 (constant -> TRUE .)


state 69

    (56) term -> factor . termaux
    (57) termaux -> . MULTIPLICATION term termaux
    (58) termaux -> . DIVISION term termaux
    (59) termaux -> . empty
    (87) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 95
    DIVISION        shift and go to state 94
    PLUS            reduce using rule 87 (empty -> .)
    MINUS           reduce using rule 87 (empty -> .)
    AND             reduce using rule 87 (empty -> .)
    DOUBEQUAL       reduce using rule 87 (empty -> .)
    NOT             reduce using rule 87 (empty -> .)
    OR              reduce using rule 87 (empty -> .)
    LESSTHANEQUAL   reduce using rule 87 (empty -> .)
    GREATTHANEQUAL  reduce using rule 87 (empty -> .)
    GREATTHAN       reduce using rule 87 (empty -> .)
    LESSTHAN        reduce using rule 87 (empty -> .)
    SEMICOLON       reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    RGTPAREN        reduce using rule 87 (empty -> .)
    RGTBRACSQR      reduce using rule 87 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 87 (empty -> .) ]
  ! DIVISION        [ reduce using rule 87 (empty -> .) ]

    termaux                        shift and go to state 96
    empty                          shift and go to state 97

state 70

    (40) factor -> PLUS . constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    constant                       shift and go to state 98
    call2                          shift and go to state 67
    array                          shift and go to state 64
    cteN                           shift and go to state 65

state 71

    (32) cteS -> STRING .

    MULTIPLICATION  reduce using rule 32 (cteS -> STRING .)
    DIVISION        reduce using rule 32 (cteS -> STRING .)
    PLUS            reduce using rule 32 (cteS -> STRING .)
    MINUS           reduce using rule 32 (cteS -> STRING .)
    AND             reduce using rule 32 (cteS -> STRING .)
    DOUBEQUAL       reduce using rule 32 (cteS -> STRING .)
    NOT             reduce using rule 32 (cteS -> STRING .)
    OR              reduce using rule 32 (cteS -> STRING .)
    LESSTHANEQUAL   reduce using rule 32 (cteS -> STRING .)
    GREATTHANEQUAL  reduce using rule 32 (cteS -> STRING .)
    GREATTHAN       reduce using rule 32 (cteS -> STRING .)
    LESSTHAN        reduce using rule 32 (cteS -> STRING .)
    SEMICOLON       reduce using rule 32 (cteS -> STRING .)
    COMMA           reduce using rule 32 (cteS -> STRING .)
    RGTPAREN        reduce using rule 32 (cteS -> STRING .)
    RGTBRACSQR      reduce using rule 32 (cteS -> STRING .)


state 72

    (37) factor -> LFTPAREN . expression RGTPAREN
    (41) expression -> . exp
    (42) expression -> . exp expressionaux exp
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    term                           shift and go to state 74
    constant                       shift and go to state 62
    cteS                           shift and go to state 63
    cteN                           shift and go to state 65
    call2                          shift and go to state 67
    exp                            shift and go to state 78
    factor                         shift and go to state 69
    array                          shift and go to state 64
    expression                     shift and go to state 99

state 73

    (23) constant -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR
    (83) call2 -> ID . LFTPAREN exp callaux RGTPAREN

    MULTIPLICATION  reduce using rule 23 (constant -> ID .)
    DIVISION        reduce using rule 23 (constant -> ID .)
    PLUS            reduce using rule 23 (constant -> ID .)
    MINUS           reduce using rule 23 (constant -> ID .)
    COMMA           reduce using rule 23 (constant -> ID .)
    RGTPAREN        reduce using rule 23 (constant -> ID .)
    RGTBRACSQR      reduce using rule 23 (constant -> ID .)
    AND             reduce using rule 23 (constant -> ID .)
    DOUBEQUAL       reduce using rule 23 (constant -> ID .)
    NOT             reduce using rule 23 (constant -> ID .)
    OR              reduce using rule 23 (constant -> ID .)
    LESSTHANEQUAL   reduce using rule 23 (constant -> ID .)
    GREATTHANEQUAL  reduce using rule 23 (constant -> ID .)
    GREATTHAN       reduce using rule 23 (constant -> ID .)
    LESSTHAN        reduce using rule 23 (constant -> ID .)
    SEMICOLON       reduce using rule 23 (constant -> ID .)
    LFTBRACSQR      shift and go to state 88
    LFTPAREN        shift and go to state 100


state 74

    (33) exp -> term . expaux
    (34) expaux -> . PLUS exp expaux
    (35) expaux -> . MINUS exp expaux
    (36) expaux -> . empty
    (87) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             reduce using rule 87 (empty -> .)
    DOUBEQUAL       reduce using rule 87 (empty -> .)
    NOT             reduce using rule 87 (empty -> .)
    OR              reduce using rule 87 (empty -> .)
    LESSTHANEQUAL   reduce using rule 87 (empty -> .)
    GREATTHANEQUAL  reduce using rule 87 (empty -> .)
    GREATTHAN       reduce using rule 87 (empty -> .)
    LESSTHAN        reduce using rule 87 (empty -> .)
    SEMICOLON       reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    RGTPAREN        reduce using rule 87 (empty -> .)
    RGTBRACSQR      reduce using rule 87 (empty -> .)

  ! PLUS            [ reduce using rule 87 (empty -> .) ]
  ! MINUS           [ reduce using rule 87 (empty -> .) ]

    expaux                         shift and go to state 101
    empty                          shift and go to state 104

state 75

    (28) constant -> FALSE .

    MULTIPLICATION  reduce using rule 28 (constant -> FALSE .)
    DIVISION        reduce using rule 28 (constant -> FALSE .)
    PLUS            reduce using rule 28 (constant -> FALSE .)
    MINUS           reduce using rule 28 (constant -> FALSE .)
    COMMA           reduce using rule 28 (constant -> FALSE .)
    RGTPAREN        reduce using rule 28 (constant -> FALSE .)
    RGTBRACSQR      reduce using rule 28 (constant -> FALSE .)
    AND             reduce using rule 28 (constant -> FALSE .)
    DOUBEQUAL       reduce using rule 28 (constant -> FALSE .)
    NOT             reduce using rule 28 (constant -> FALSE .)
    OR              reduce using rule 28 (constant -> FALSE .)
    LESSTHANEQUAL   reduce using rule 28 (constant -> FALSE .)
    GREATTHANEQUAL  reduce using rule 28 (constant -> FALSE .)
    GREATTHAN       reduce using rule 28 (constant -> FALSE .)
    LESSTHAN        reduce using rule 28 (constant -> FALSE .)
    SEMICOLON       reduce using rule 28 (constant -> FALSE .)


state 76

    (31) cteN -> INT .

    MULTIPLICATION  reduce using rule 31 (cteN -> INT .)
    DIVISION        reduce using rule 31 (cteN -> INT .)
    PLUS            reduce using rule 31 (cteN -> INT .)
    MINUS           reduce using rule 31 (cteN -> INT .)
    AND             reduce using rule 31 (cteN -> INT .)
    DOUBEQUAL       reduce using rule 31 (cteN -> INT .)
    NOT             reduce using rule 31 (cteN -> INT .)
    OR              reduce using rule 31 (cteN -> INT .)
    LESSTHANEQUAL   reduce using rule 31 (cteN -> INT .)
    GREATTHANEQUAL  reduce using rule 31 (cteN -> INT .)
    GREATTHAN       reduce using rule 31 (cteN -> INT .)
    LESSTHAN        reduce using rule 31 (cteN -> INT .)
    RGTPAREN        reduce using rule 31 (cteN -> INT .)
    RGTBRACSQR      reduce using rule 31 (cteN -> INT .)
    SEMICOLON       reduce using rule 31 (cteN -> INT .)
    COMMA           reduce using rule 31 (cteN -> INT .)


state 77

    (30) cteN -> FLOAT .

    MULTIPLICATION  reduce using rule 30 (cteN -> FLOAT .)
    DIVISION        reduce using rule 30 (cteN -> FLOAT .)
    PLUS            reduce using rule 30 (cteN -> FLOAT .)
    MINUS           reduce using rule 30 (cteN -> FLOAT .)
    AND             reduce using rule 30 (cteN -> FLOAT .)
    DOUBEQUAL       reduce using rule 30 (cteN -> FLOAT .)
    NOT             reduce using rule 30 (cteN -> FLOAT .)
    OR              reduce using rule 30 (cteN -> FLOAT .)
    LESSTHANEQUAL   reduce using rule 30 (cteN -> FLOAT .)
    GREATTHANEQUAL  reduce using rule 30 (cteN -> FLOAT .)
    GREATTHAN       reduce using rule 30 (cteN -> FLOAT .)
    LESSTHAN        reduce using rule 30 (cteN -> FLOAT .)
    RGTPAREN        reduce using rule 30 (cteN -> FLOAT .)
    RGTBRACSQR      reduce using rule 30 (cteN -> FLOAT .)
    SEMICOLON       reduce using rule 30 (cteN -> FLOAT .)
    COMMA           reduce using rule 30 (cteN -> FLOAT .)


state 78

    (41) expression -> exp .
    (42) expression -> exp . expressionaux exp
    (43) expressionaux -> . AND
    (44) expressionaux -> . DOUBEQUAL
    (45) expressionaux -> . NOT
    (46) expressionaux -> . OR
    (47) expressionaux -> . LESSTHANEQUAL
    (48) expressionaux -> . GREATTHANEQUAL
    (49) expressionaux -> . GREATTHAN
    (50) expressionaux -> . LESSTHAN

    SEMICOLON       reduce using rule 41 (expression -> exp .)
    COMMA           reduce using rule 41 (expression -> exp .)
    RGTPAREN        reduce using rule 41 (expression -> exp .)
    AND             shift and go to state 105
    DOUBEQUAL       shift and go to state 112
    NOT             shift and go to state 111
    OR              shift and go to state 113
    LESSTHANEQUAL   shift and go to state 109
    GREATTHANEQUAL  shift and go to state 107
    GREATTHAN       shift and go to state 108
    LESSTHAN        shift and go to state 110

    expressionaux                  shift and go to state 106

state 79

    (76) varsaux -> ID codeAddVar EQUAL expression . SEMICOLON
    (77) varsaux -> ID codeAddVar EQUAL expression . COMMA varsaux

    SEMICOLON       shift and go to state 114
    COMMA           shift and go to state 115


state 80

    (72) function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN . parameter RGTPAREN blockreturn codeScope
    (53) parameter -> . type ID codeAddParameters
    (54) parameter -> . type ID codeAddParameters COMMA parameter
    (55) parameter -> . empty
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType
    (87) empty -> .

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11
    RGTPAREN        reduce using rule 87 (empty -> .)

    type                           shift and go to state 116
    parameter                      shift and go to state 117
    empty                          shift and go to state 118

state 81

    (15) blockneutral -> vars blockneutral .

    RGTBRAC         reduce using rule 15 (blockneutral -> vars blockneutral .)
    RETURN          reduce using rule 15 (blockneutral -> vars blockneutral .)


state 82

    (84) read -> READ LFTPAREN . readaux RGTPAREN SEMICOLON
    (85) readaux -> . ID
    (86) readaux -> . array
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    ID              shift and go to state 121

    readaux                        shift and go to state 119
    array                          shift and go to state 120

state 83

    (51) loop -> WHILE LFTPAREN . expression RGTPAREN block
    (41) expression -> . exp
    (42) expression -> . exp expressionaux exp
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    term                           shift and go to state 74
    constant                       shift and go to state 62
    cteS                           shift and go to state 63
    cteN                           shift and go to state 65
    call2                          shift and go to state 67
    exp                            shift and go to state 78
    factor                         shift and go to state 69
    array                          shift and go to state 64
    expression                     shift and go to state 122

state 84

    (52) write -> PRINT LFTPAREN . constant RGTPAREN SEMICOLON
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    constant                       shift and go to state 123
    call2                          shift and go to state 67
    array                          shift and go to state 64
    cteN                           shift and go to state 65

state 85

    (14) blockneutral -> statement blockneutral .

    RGTBRAC         reduce using rule 14 (blockneutral -> statement blockneutral .)
    RETURN          reduce using rule 14 (blockneutral -> statement blockneutral .)


state 86

    (9) assignment -> assignmentaux EQUAL . expression SEMICOLON
    (41) expression -> . exp
    (42) expression -> . exp expressionaux exp
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    term                           shift and go to state 74
    constant                       shift and go to state 62
    cteS                           shift and go to state 63
    cteN                           shift and go to state 65
    call2                          shift and go to state 67
    exp                            shift and go to state 78
    factor                         shift and go to state 69
    array                          shift and go to state 64
    expression                     shift and go to state 124

state 87

    (80) call -> ID LFTPAREN . exp callaux RGTPAREN SEMICOLON
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 125
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 88

    (5) array -> ID LFTBRACSQR . exp RGTBRACSQR
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 126
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 89

    (20) conditionaux -> LFTPAREN . expression RGTPAREN block conditionaux2
    (41) expression -> . exp
    (42) expression -> . exp expressionaux exp
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    term                           shift and go to state 74
    constant                       shift and go to state 62
    cteS                           shift and go to state 63
    cteN                           shift and go to state 65
    call2                          shift and go to state 67
    exp                            shift and go to state 78
    factor                         shift and go to state 69
    array                          shift and go to state 64
    expression                     shift and go to state 127

state 90

    (18) condition -> IF conditionaux .
    (19) condition -> IF conditionaux . ELSE block

    IF              reduce using rule 18 (condition -> IF conditionaux .)
    WHILE           reduce using rule 18 (condition -> IF conditionaux .)
    PRINT           reduce using rule 18 (condition -> IF conditionaux .)
    READ            reduce using rule 18 (condition -> IF conditionaux .)
    ID              reduce using rule 18 (condition -> IF conditionaux .)
    INT             reduce using rule 18 (condition -> IF conditionaux .)
    FLOAT           reduce using rule 18 (condition -> IF conditionaux .)
    CHAR            reduce using rule 18 (condition -> IF conditionaux .)
    BOOL            reduce using rule 18 (condition -> IF conditionaux .)
    STRING          reduce using rule 18 (condition -> IF conditionaux .)
    RGTBRAC         reduce using rule 18 (condition -> IF conditionaux .)
    RETURN          reduce using rule 18 (condition -> IF conditionaux .)
    ELSE            shift and go to state 128


state 91

    (17) block -> LFTBRAC blockneutral RGTBRAC .

    IF              reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    WHILE           reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    PRINT           reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    READ            reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    ID              reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    INT             reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    FLOAT           reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    CHAR            reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    BOOL            reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    STRING          reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    RGTBRAC         reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    RETURN          reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    ELSEIF          reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)
    ELSE            reduce using rule 17 (block -> LFTBRAC blockneutral RGTBRAC .)


state 92

    (78) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR . EQUAL arrayvalues SEMICOLON
    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR . EQUAL arrayvalues COMMA varsaux

    EQUAL           shift and go to state 129


state 93

    (39) factor -> MINUS constant .

    MULTIPLICATION  reduce using rule 39 (factor -> MINUS constant .)
    DIVISION        reduce using rule 39 (factor -> MINUS constant .)
    PLUS            reduce using rule 39 (factor -> MINUS constant .)
    MINUS           reduce using rule 39 (factor -> MINUS constant .)
    RGTBRACSQR      reduce using rule 39 (factor -> MINUS constant .)
    COMMA           reduce using rule 39 (factor -> MINUS constant .)
    RGTPAREN        reduce using rule 39 (factor -> MINUS constant .)
    SEMICOLON       reduce using rule 39 (factor -> MINUS constant .)
    AND             reduce using rule 39 (factor -> MINUS constant .)
    DOUBEQUAL       reduce using rule 39 (factor -> MINUS constant .)
    NOT             reduce using rule 39 (factor -> MINUS constant .)
    OR              reduce using rule 39 (factor -> MINUS constant .)
    LESSTHANEQUAL   reduce using rule 39 (factor -> MINUS constant .)
    GREATTHANEQUAL  reduce using rule 39 (factor -> MINUS constant .)
    GREATTHAN       reduce using rule 39 (factor -> MINUS constant .)
    LESSTHAN        reduce using rule 39 (factor -> MINUS constant .)


state 94

    (58) termaux -> DIVISION . term termaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 130
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 95

    (57) termaux -> MULTIPLICATION . term termaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 131
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 96

    (56) term -> factor termaux .

    MULTIPLICATION  reduce using rule 56 (term -> factor termaux .)
    DIVISION        reduce using rule 56 (term -> factor termaux .)
    PLUS            reduce using rule 56 (term -> factor termaux .)
    MINUS           reduce using rule 56 (term -> factor termaux .)
    AND             reduce using rule 56 (term -> factor termaux .)
    DOUBEQUAL       reduce using rule 56 (term -> factor termaux .)
    NOT             reduce using rule 56 (term -> factor termaux .)
    OR              reduce using rule 56 (term -> factor termaux .)
    LESSTHANEQUAL   reduce using rule 56 (term -> factor termaux .)
    GREATTHANEQUAL  reduce using rule 56 (term -> factor termaux .)
    GREATTHAN       reduce using rule 56 (term -> factor termaux .)
    LESSTHAN        reduce using rule 56 (term -> factor termaux .)
    SEMICOLON       reduce using rule 56 (term -> factor termaux .)
    COMMA           reduce using rule 56 (term -> factor termaux .)
    RGTPAREN        reduce using rule 56 (term -> factor termaux .)
    RGTBRACSQR      reduce using rule 56 (term -> factor termaux .)


state 97

    (59) termaux -> empty .

    MULTIPLICATION  reduce using rule 59 (termaux -> empty .)
    DIVISION        reduce using rule 59 (termaux -> empty .)
    PLUS            reduce using rule 59 (termaux -> empty .)
    MINUS           reduce using rule 59 (termaux -> empty .)
    AND             reduce using rule 59 (termaux -> empty .)
    DOUBEQUAL       reduce using rule 59 (termaux -> empty .)
    NOT             reduce using rule 59 (termaux -> empty .)
    OR              reduce using rule 59 (termaux -> empty .)
    LESSTHANEQUAL   reduce using rule 59 (termaux -> empty .)
    GREATTHANEQUAL  reduce using rule 59 (termaux -> empty .)
    GREATTHAN       reduce using rule 59 (termaux -> empty .)
    LESSTHAN        reduce using rule 59 (termaux -> empty .)
    SEMICOLON       reduce using rule 59 (termaux -> empty .)
    COMMA           reduce using rule 59 (termaux -> empty .)
    RGTPAREN        reduce using rule 59 (termaux -> empty .)
    RGTBRACSQR      reduce using rule 59 (termaux -> empty .)


state 98

    (40) factor -> PLUS constant .

    MULTIPLICATION  reduce using rule 40 (factor -> PLUS constant .)
    DIVISION        reduce using rule 40 (factor -> PLUS constant .)
    PLUS            reduce using rule 40 (factor -> PLUS constant .)
    MINUS           reduce using rule 40 (factor -> PLUS constant .)
    RGTBRACSQR      reduce using rule 40 (factor -> PLUS constant .)
    COMMA           reduce using rule 40 (factor -> PLUS constant .)
    RGTPAREN        reduce using rule 40 (factor -> PLUS constant .)
    SEMICOLON       reduce using rule 40 (factor -> PLUS constant .)
    AND             reduce using rule 40 (factor -> PLUS constant .)
    DOUBEQUAL       reduce using rule 40 (factor -> PLUS constant .)
    NOT             reduce using rule 40 (factor -> PLUS constant .)
    OR              reduce using rule 40 (factor -> PLUS constant .)
    LESSTHANEQUAL   reduce using rule 40 (factor -> PLUS constant .)
    GREATTHANEQUAL  reduce using rule 40 (factor -> PLUS constant .)
    GREATTHAN       reduce using rule 40 (factor -> PLUS constant .)
    LESSTHAN        reduce using rule 40 (factor -> PLUS constant .)


state 99

    (37) factor -> LFTPAREN expression . RGTPAREN

    RGTPAREN        shift and go to state 132


state 100

    (83) call2 -> ID LFTPAREN . exp callaux RGTPAREN
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 133
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 101

    (33) exp -> term expaux .

    SEMICOLON       reduce using rule 33 (exp -> term expaux .)
    COMMA           reduce using rule 33 (exp -> term expaux .)
    RGTPAREN        reduce using rule 33 (exp -> term expaux .)
    AND             reduce using rule 33 (exp -> term expaux .)
    DOUBEQUAL       reduce using rule 33 (exp -> term expaux .)
    NOT             reduce using rule 33 (exp -> term expaux .)
    OR              reduce using rule 33 (exp -> term expaux .)
    LESSTHANEQUAL   reduce using rule 33 (exp -> term expaux .)
    GREATTHANEQUAL  reduce using rule 33 (exp -> term expaux .)
    GREATTHAN       reduce using rule 33 (exp -> term expaux .)
    LESSTHAN        reduce using rule 33 (exp -> term expaux .)
    PLUS            reduce using rule 33 (exp -> term expaux .)
    MINUS           reduce using rule 33 (exp -> term expaux .)
    RGTBRACSQR      reduce using rule 33 (exp -> term expaux .)


state 102

    (34) expaux -> PLUS . exp expaux
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 134
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 103

    (35) expaux -> MINUS . exp expaux
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 135
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 104

    (36) expaux -> empty .

    PLUS            reduce using rule 36 (expaux -> empty .)
    MINUS           reduce using rule 36 (expaux -> empty .)
    AND             reduce using rule 36 (expaux -> empty .)
    DOUBEQUAL       reduce using rule 36 (expaux -> empty .)
    NOT             reduce using rule 36 (expaux -> empty .)
    OR              reduce using rule 36 (expaux -> empty .)
    LESSTHANEQUAL   reduce using rule 36 (expaux -> empty .)
    GREATTHANEQUAL  reduce using rule 36 (expaux -> empty .)
    GREATTHAN       reduce using rule 36 (expaux -> empty .)
    LESSTHAN        reduce using rule 36 (expaux -> empty .)
    SEMICOLON       reduce using rule 36 (expaux -> empty .)
    COMMA           reduce using rule 36 (expaux -> empty .)
    RGTPAREN        reduce using rule 36 (expaux -> empty .)
    RGTBRACSQR      reduce using rule 36 (expaux -> empty .)


state 105

    (43) expressionaux -> AND .

    LFTPAREN        reduce using rule 43 (expressionaux -> AND .)
    MINUS           reduce using rule 43 (expressionaux -> AND .)
    PLUS            reduce using rule 43 (expressionaux -> AND .)
    ID              reduce using rule 43 (expressionaux -> AND .)
    TRUE            reduce using rule 43 (expressionaux -> AND .)
    FALSE           reduce using rule 43 (expressionaux -> AND .)
    FLOAT           reduce using rule 43 (expressionaux -> AND .)
    INT             reduce using rule 43 (expressionaux -> AND .)
    STRING          reduce using rule 43 (expressionaux -> AND .)


state 106

    (42) expression -> exp expressionaux . exp
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    term                           shift and go to state 74
    constant                       shift and go to state 62
    cteS                           shift and go to state 63
    cteN                           shift and go to state 65
    call2                          shift and go to state 67
    exp                            shift and go to state 136
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 107

    (48) expressionaux -> GREATTHANEQUAL .

    LFTPAREN        reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    MINUS           reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    PLUS            reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    ID              reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    TRUE            reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    FALSE           reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    FLOAT           reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    INT             reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)
    STRING          reduce using rule 48 (expressionaux -> GREATTHANEQUAL .)


state 108

    (49) expressionaux -> GREATTHAN .

    LFTPAREN        reduce using rule 49 (expressionaux -> GREATTHAN .)
    MINUS           reduce using rule 49 (expressionaux -> GREATTHAN .)
    PLUS            reduce using rule 49 (expressionaux -> GREATTHAN .)
    ID              reduce using rule 49 (expressionaux -> GREATTHAN .)
    TRUE            reduce using rule 49 (expressionaux -> GREATTHAN .)
    FALSE           reduce using rule 49 (expressionaux -> GREATTHAN .)
    FLOAT           reduce using rule 49 (expressionaux -> GREATTHAN .)
    INT             reduce using rule 49 (expressionaux -> GREATTHAN .)
    STRING          reduce using rule 49 (expressionaux -> GREATTHAN .)


state 109

    (47) expressionaux -> LESSTHANEQUAL .

    LFTPAREN        reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    MINUS           reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    PLUS            reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    ID              reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    TRUE            reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    FALSE           reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    FLOAT           reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    INT             reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)
    STRING          reduce using rule 47 (expressionaux -> LESSTHANEQUAL .)


state 110

    (50) expressionaux -> LESSTHAN .

    LFTPAREN        reduce using rule 50 (expressionaux -> LESSTHAN .)
    MINUS           reduce using rule 50 (expressionaux -> LESSTHAN .)
    PLUS            reduce using rule 50 (expressionaux -> LESSTHAN .)
    ID              reduce using rule 50 (expressionaux -> LESSTHAN .)
    TRUE            reduce using rule 50 (expressionaux -> LESSTHAN .)
    FALSE           reduce using rule 50 (expressionaux -> LESSTHAN .)
    FLOAT           reduce using rule 50 (expressionaux -> LESSTHAN .)
    INT             reduce using rule 50 (expressionaux -> LESSTHAN .)
    STRING          reduce using rule 50 (expressionaux -> LESSTHAN .)


state 111

    (45) expressionaux -> NOT .

    LFTPAREN        reduce using rule 45 (expressionaux -> NOT .)
    MINUS           reduce using rule 45 (expressionaux -> NOT .)
    PLUS            reduce using rule 45 (expressionaux -> NOT .)
    ID              reduce using rule 45 (expressionaux -> NOT .)
    TRUE            reduce using rule 45 (expressionaux -> NOT .)
    FALSE           reduce using rule 45 (expressionaux -> NOT .)
    FLOAT           reduce using rule 45 (expressionaux -> NOT .)
    INT             reduce using rule 45 (expressionaux -> NOT .)
    STRING          reduce using rule 45 (expressionaux -> NOT .)


state 112

    (44) expressionaux -> DOUBEQUAL .

    LFTPAREN        reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    MINUS           reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    PLUS            reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    ID              reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    TRUE            reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    FALSE           reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    FLOAT           reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    INT             reduce using rule 44 (expressionaux -> DOUBEQUAL .)
    STRING          reduce using rule 44 (expressionaux -> DOUBEQUAL .)


state 113

    (46) expressionaux -> OR .

    LFTPAREN        reduce using rule 46 (expressionaux -> OR .)
    MINUS           reduce using rule 46 (expressionaux -> OR .)
    PLUS            reduce using rule 46 (expressionaux -> OR .)
    ID              reduce using rule 46 (expressionaux -> OR .)
    TRUE            reduce using rule 46 (expressionaux -> OR .)
    FALSE           reduce using rule 46 (expressionaux -> OR .)
    FLOAT           reduce using rule 46 (expressionaux -> OR .)
    INT             reduce using rule 46 (expressionaux -> OR .)
    STRING          reduce using rule 46 (expressionaux -> OR .)


state 114

    (76) varsaux -> ID codeAddVar EQUAL expression SEMICOLON .

    FUNCTION        reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    INT             reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    STRING          reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    PRIOMH          reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    IF              reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    READ            reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    ID              reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    RGTBRAC         reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 76 (varsaux -> ID codeAddVar EQUAL expression SEMICOLON .)


state 115

    (77) varsaux -> ID codeAddVar EQUAL expression COMMA . varsaux
    (76) varsaux -> . ID codeAddVar EQUAL expression SEMICOLON
    (77) varsaux -> . ID codeAddVar EQUAL expression COMMA varsaux
    (78) varsaux -> . ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> . ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux

    ID              shift and go to state 24

    varsaux                        shift and go to state 137

state 116

    (53) parameter -> type . ID codeAddParameters
    (54) parameter -> type . ID codeAddParameters COMMA parameter

    ID              shift and go to state 138


state 117

    (72) function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter . RGTPAREN blockreturn codeScope

    RGTPAREN        shift and go to state 139


state 118

    (55) parameter -> empty .

    RGTPAREN        reduce using rule 55 (parameter -> empty .)


state 119

    (84) read -> READ LFTPAREN readaux . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 140


state 120

    (86) readaux -> array .

    RGTPAREN        reduce using rule 86 (readaux -> array .)


state 121

    (85) readaux -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR

    RGTPAREN        reduce using rule 85 (readaux -> ID .)
    LFTBRACSQR      shift and go to state 88


state 122

    (51) loop -> WHILE LFTPAREN expression . RGTPAREN block

    RGTPAREN        shift and go to state 141


state 123

    (52) write -> PRINT LFTPAREN constant . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 142


state 124

    (9) assignment -> assignmentaux EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 143


state 125

    (80) call -> ID LFTPAREN exp . callaux RGTPAREN SEMICOLON
    (81) callaux -> . COMMA exp callaux
    (82) callaux -> . empty
    (87) empty -> .

    COMMA           shift and go to state 145
    RGTPAREN        reduce using rule 87 (empty -> .)

    empty                          shift and go to state 146
    callaux                        shift and go to state 144

state 126

    (5) array -> ID LFTBRACSQR exp . RGTBRACSQR

    RGTBRACSQR      shift and go to state 147


state 127

    (20) conditionaux -> LFTPAREN expression . RGTPAREN block conditionaux2

    RGTPAREN        shift and go to state 148


state 128

    (19) condition -> IF conditionaux ELSE . block
    (17) block -> . LFTBRAC blockneutral RGTBRAC

    LFTBRAC         shift and go to state 38

    block                          shift and go to state 149

state 129

    (78) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL . arrayvalues SEMICOLON
    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL . arrayvalues COMMA varsaux
    (6) arrayvalues -> . LFTBRACSQR arrayvaluesaux RGTBRACSQR

    LFTBRACSQR      shift and go to state 150

    arrayvalues                    shift and go to state 151

state 130

    (58) termaux -> DIVISION term . termaux
    (57) termaux -> . MULTIPLICATION term termaux
    (58) termaux -> . DIVISION term termaux
    (59) termaux -> . empty
    (87) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 95
    DIVISION        shift and go to state 94
    PLUS            reduce using rule 87 (empty -> .)
    MINUS           reduce using rule 87 (empty -> .)
    AND             reduce using rule 87 (empty -> .)
    DOUBEQUAL       reduce using rule 87 (empty -> .)
    NOT             reduce using rule 87 (empty -> .)
    OR              reduce using rule 87 (empty -> .)
    LESSTHANEQUAL   reduce using rule 87 (empty -> .)
    GREATTHANEQUAL  reduce using rule 87 (empty -> .)
    GREATTHAN       reduce using rule 87 (empty -> .)
    LESSTHAN        reduce using rule 87 (empty -> .)
    SEMICOLON       reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    RGTPAREN        reduce using rule 87 (empty -> .)
    RGTBRACSQR      reduce using rule 87 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 87 (empty -> .) ]
  ! DIVISION        [ reduce using rule 87 (empty -> .) ]

    termaux                        shift and go to state 152
    empty                          shift and go to state 97

state 131

    (57) termaux -> MULTIPLICATION term . termaux
    (57) termaux -> . MULTIPLICATION term termaux
    (58) termaux -> . DIVISION term termaux
    (59) termaux -> . empty
    (87) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 95
    DIVISION        shift and go to state 94
    PLUS            reduce using rule 87 (empty -> .)
    MINUS           reduce using rule 87 (empty -> .)
    AND             reduce using rule 87 (empty -> .)
    DOUBEQUAL       reduce using rule 87 (empty -> .)
    NOT             reduce using rule 87 (empty -> .)
    OR              reduce using rule 87 (empty -> .)
    LESSTHANEQUAL   reduce using rule 87 (empty -> .)
    GREATTHANEQUAL  reduce using rule 87 (empty -> .)
    GREATTHAN       reduce using rule 87 (empty -> .)
    LESSTHAN        reduce using rule 87 (empty -> .)
    SEMICOLON       reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    RGTPAREN        reduce using rule 87 (empty -> .)
    RGTBRACSQR      reduce using rule 87 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 87 (empty -> .) ]
  ! DIVISION        [ reduce using rule 87 (empty -> .) ]

    termaux                        shift and go to state 153
    empty                          shift and go to state 97

state 132

    (37) factor -> LFTPAREN expression RGTPAREN .

    MULTIPLICATION  reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    DIVISION        reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    PLUS            reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    MINUS           reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    RGTBRACSQR      reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    COMMA           reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    RGTPAREN        reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    SEMICOLON       reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    AND             reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    DOUBEQUAL       reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    NOT             reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    OR              reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    LESSTHANEQUAL   reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    GREATTHANEQUAL  reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    GREATTHAN       reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)
    LESSTHAN        reduce using rule 37 (factor -> LFTPAREN expression RGTPAREN .)


state 133

    (83) call2 -> ID LFTPAREN exp . callaux RGTPAREN
    (81) callaux -> . COMMA exp callaux
    (82) callaux -> . empty
    (87) empty -> .

    COMMA           shift and go to state 145
    RGTPAREN        reduce using rule 87 (empty -> .)

    empty                          shift and go to state 146
    callaux                        shift and go to state 154

state 134

    (34) expaux -> PLUS exp . expaux
    (34) expaux -> . PLUS exp expaux
    (35) expaux -> . MINUS exp expaux
    (36) expaux -> . empty
    (87) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             reduce using rule 87 (empty -> .)
    DOUBEQUAL       reduce using rule 87 (empty -> .)
    NOT             reduce using rule 87 (empty -> .)
    OR              reduce using rule 87 (empty -> .)
    LESSTHANEQUAL   reduce using rule 87 (empty -> .)
    GREATTHANEQUAL  reduce using rule 87 (empty -> .)
    GREATTHAN       reduce using rule 87 (empty -> .)
    LESSTHAN        reduce using rule 87 (empty -> .)
    SEMICOLON       reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    RGTPAREN        reduce using rule 87 (empty -> .)
    RGTBRACSQR      reduce using rule 87 (empty -> .)

  ! PLUS            [ reduce using rule 87 (empty -> .) ]
  ! MINUS           [ reduce using rule 87 (empty -> .) ]

    expaux                         shift and go to state 155
    empty                          shift and go to state 104

state 135

    (35) expaux -> MINUS exp . expaux
    (34) expaux -> . PLUS exp expaux
    (35) expaux -> . MINUS exp expaux
    (36) expaux -> . empty
    (87) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             reduce using rule 87 (empty -> .)
    DOUBEQUAL       reduce using rule 87 (empty -> .)
    NOT             reduce using rule 87 (empty -> .)
    OR              reduce using rule 87 (empty -> .)
    LESSTHANEQUAL   reduce using rule 87 (empty -> .)
    GREATTHANEQUAL  reduce using rule 87 (empty -> .)
    GREATTHAN       reduce using rule 87 (empty -> .)
    LESSTHAN        reduce using rule 87 (empty -> .)
    SEMICOLON       reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    RGTPAREN        reduce using rule 87 (empty -> .)
    RGTBRACSQR      reduce using rule 87 (empty -> .)

  ! PLUS            [ reduce using rule 87 (empty -> .) ]
  ! MINUS           [ reduce using rule 87 (empty -> .) ]

    expaux                         shift and go to state 156
    empty                          shift and go to state 104

state 136

    (42) expression -> exp expressionaux exp .

    SEMICOLON       reduce using rule 42 (expression -> exp expressionaux exp .)
    COMMA           reduce using rule 42 (expression -> exp expressionaux exp .)
    RGTPAREN        reduce using rule 42 (expression -> exp expressionaux exp .)


state 137

    (77) varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .

    FUNCTION        reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    INT             reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    FLOAT           reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    CHAR            reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    BOOL            reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    STRING          reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    PRIOMH          reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    IF              reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    WHILE           reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    PRINT           reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    READ            reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    ID              reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    RGTBRAC         reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)
    RETURN          reduce using rule 77 (varsaux -> ID codeAddVar EQUAL expression COMMA varsaux .)


state 138

    (53) parameter -> type ID . codeAddParameters
    (54) parameter -> type ID . codeAddParameters COMMA parameter
    (92) codeAddParameters -> .

    COMMA           reduce using rule 92 (codeAddParameters -> .)
    RGTPAREN        reduce using rule 92 (codeAddParameters -> .)

    codeAddParameters              shift and go to state 157

state 139

    (72) function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN . blockreturn codeScope
    (12) blockreturn -> . LFTBRAC blockneutral RGTBRAC
    (13) blockreturn -> . LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC

    LFTBRAC         shift and go to state 158

    blockreturn                    shift and go to state 159

state 140

    (84) read -> READ LFTPAREN readaux RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 160


state 141

    (51) loop -> WHILE LFTPAREN expression RGTPAREN . block
    (17) block -> . LFTBRAC blockneutral RGTBRAC

    LFTBRAC         shift and go to state 38

    block                          shift and go to state 161

state 142

    (52) write -> PRINT LFTPAREN constant RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 162


state 143

    (9) assignment -> assignmentaux EQUAL expression SEMICOLON .

    IF              reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    READ            reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    ID              reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    INT             reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    STRING          reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    RGTBRAC         reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 9 (assignment -> assignmentaux EQUAL expression SEMICOLON .)


state 144

    (80) call -> ID LFTPAREN exp callaux . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 163


state 145

    (81) callaux -> COMMA . exp callaux
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 164
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 146

    (82) callaux -> empty .

    RGTPAREN        reduce using rule 82 (callaux -> empty .)


state 147

    (5) array -> ID LFTBRACSQR exp RGTBRACSQR .

    EQUAL           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    MULTIPLICATION  reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    DIVISION        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    PLUS            reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    MINUS           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    AND             reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    DOUBEQUAL       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    NOT             reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    OR              reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    LESSTHANEQUAL   reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    GREATTHANEQUAL  reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    GREATTHAN       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    LESSTHAN        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    SEMICOLON       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    COMMA           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    RGTPAREN        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    RGTBRACSQR      reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)


state 148

    (20) conditionaux -> LFTPAREN expression RGTPAREN . block conditionaux2
    (17) block -> . LFTBRAC blockneutral RGTBRAC

    LFTBRAC         shift and go to state 38

    block                          shift and go to state 165

state 149

    (19) condition -> IF conditionaux ELSE block .

    IF              reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    WHILE           reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    PRINT           reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    READ            reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    ID              reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    INT             reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    FLOAT           reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    CHAR            reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    BOOL            reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    STRING          reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    RGTBRAC         reduce using rule 19 (condition -> IF conditionaux ELSE block .)
    RETURN          reduce using rule 19 (condition -> IF conditionaux ELSE block .)


state 150

    (6) arrayvalues -> LFTBRACSQR . arrayvaluesaux RGTBRACSQR
    (7) arrayvaluesaux -> . constant
    (8) arrayvaluesaux -> . constant COMMA arrayvaluesaux
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    constant                       shift and go to state 166
    call2                          shift and go to state 67
    array                          shift and go to state 64
    cteN                           shift and go to state 65
    arrayvaluesaux                 shift and go to state 167

state 151

    (78) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues . SEMICOLON
    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues . COMMA varsaux

    SEMICOLON       shift and go to state 168
    COMMA           shift and go to state 169


state 152

    (58) termaux -> DIVISION term termaux .

    MULTIPLICATION  reduce using rule 58 (termaux -> DIVISION term termaux .)
    DIVISION        reduce using rule 58 (termaux -> DIVISION term termaux .)
    PLUS            reduce using rule 58 (termaux -> DIVISION term termaux .)
    MINUS           reduce using rule 58 (termaux -> DIVISION term termaux .)
    AND             reduce using rule 58 (termaux -> DIVISION term termaux .)
    DOUBEQUAL       reduce using rule 58 (termaux -> DIVISION term termaux .)
    NOT             reduce using rule 58 (termaux -> DIVISION term termaux .)
    OR              reduce using rule 58 (termaux -> DIVISION term termaux .)
    LESSTHANEQUAL   reduce using rule 58 (termaux -> DIVISION term termaux .)
    GREATTHANEQUAL  reduce using rule 58 (termaux -> DIVISION term termaux .)
    GREATTHAN       reduce using rule 58 (termaux -> DIVISION term termaux .)
    LESSTHAN        reduce using rule 58 (termaux -> DIVISION term termaux .)
    SEMICOLON       reduce using rule 58 (termaux -> DIVISION term termaux .)
    COMMA           reduce using rule 58 (termaux -> DIVISION term termaux .)
    RGTPAREN        reduce using rule 58 (termaux -> DIVISION term termaux .)
    RGTBRACSQR      reduce using rule 58 (termaux -> DIVISION term termaux .)


state 153

    (57) termaux -> MULTIPLICATION term termaux .

    MULTIPLICATION  reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    DIVISION        reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    PLUS            reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    MINUS           reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    AND             reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    DOUBEQUAL       reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    NOT             reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    OR              reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    LESSTHANEQUAL   reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    GREATTHANEQUAL  reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    GREATTHAN       reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    LESSTHAN        reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    SEMICOLON       reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    COMMA           reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    RGTPAREN        reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)
    RGTBRACSQR      reduce using rule 57 (termaux -> MULTIPLICATION term termaux .)


state 154

    (83) call2 -> ID LFTPAREN exp callaux . RGTPAREN

    RGTPAREN        shift and go to state 170


state 155

    (34) expaux -> PLUS exp expaux .

    PLUS            reduce using rule 34 (expaux -> PLUS exp expaux .)
    MINUS           reduce using rule 34 (expaux -> PLUS exp expaux .)
    AND             reduce using rule 34 (expaux -> PLUS exp expaux .)
    DOUBEQUAL       reduce using rule 34 (expaux -> PLUS exp expaux .)
    NOT             reduce using rule 34 (expaux -> PLUS exp expaux .)
    OR              reduce using rule 34 (expaux -> PLUS exp expaux .)
    LESSTHANEQUAL   reduce using rule 34 (expaux -> PLUS exp expaux .)
    GREATTHANEQUAL  reduce using rule 34 (expaux -> PLUS exp expaux .)
    GREATTHAN       reduce using rule 34 (expaux -> PLUS exp expaux .)
    LESSTHAN        reduce using rule 34 (expaux -> PLUS exp expaux .)
    SEMICOLON       reduce using rule 34 (expaux -> PLUS exp expaux .)
    COMMA           reduce using rule 34 (expaux -> PLUS exp expaux .)
    RGTPAREN        reduce using rule 34 (expaux -> PLUS exp expaux .)
    RGTBRACSQR      reduce using rule 34 (expaux -> PLUS exp expaux .)


state 156

    (35) expaux -> MINUS exp expaux .

    PLUS            reduce using rule 35 (expaux -> MINUS exp expaux .)
    MINUS           reduce using rule 35 (expaux -> MINUS exp expaux .)
    AND             reduce using rule 35 (expaux -> MINUS exp expaux .)
    DOUBEQUAL       reduce using rule 35 (expaux -> MINUS exp expaux .)
    NOT             reduce using rule 35 (expaux -> MINUS exp expaux .)
    OR              reduce using rule 35 (expaux -> MINUS exp expaux .)
    LESSTHANEQUAL   reduce using rule 35 (expaux -> MINUS exp expaux .)
    GREATTHANEQUAL  reduce using rule 35 (expaux -> MINUS exp expaux .)
    GREATTHAN       reduce using rule 35 (expaux -> MINUS exp expaux .)
    LESSTHAN        reduce using rule 35 (expaux -> MINUS exp expaux .)
    SEMICOLON       reduce using rule 35 (expaux -> MINUS exp expaux .)
    COMMA           reduce using rule 35 (expaux -> MINUS exp expaux .)
    RGTPAREN        reduce using rule 35 (expaux -> MINUS exp expaux .)
    RGTBRACSQR      reduce using rule 35 (expaux -> MINUS exp expaux .)


state 157

    (53) parameter -> type ID codeAddParameters .
    (54) parameter -> type ID codeAddParameters . COMMA parameter

    RGTPAREN        reduce using rule 53 (parameter -> type ID codeAddParameters .)
    COMMA           shift and go to state 171


state 158

    (12) blockreturn -> LFTBRAC . blockneutral RGTBRAC
    (13) blockreturn -> LFTBRAC . blockneutral RETURN exp SEMICOLON RGTBRAC
    (14) blockneutral -> . statement blockneutral
    (15) blockneutral -> . vars blockneutral
    (16) blockneutral -> . empty
    (60) statement -> . assignment
    (61) statement -> . condition
    (62) statement -> . loop
    (63) statement -> . write
    (64) statement -> . read
    (65) statement -> . call
    (75) vars -> . type varsaux
    (87) empty -> .
    (9) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (18) condition -> . IF conditionaux
    (19) condition -> . IF conditionaux ELSE block
    (51) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (52) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN readaux RGTPAREN SEMICOLON
    (80) call -> . ID LFTPAREN exp callaux RGTPAREN SEMICOLON
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType
    (10) assignmentaux -> . ID
    (11) assignmentaux -> . array
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 87 (empty -> .)
    RETURN          reduce using rule 87 (empty -> .)
    IF              shift and go to state 58
    WHILE           shift and go to state 46
    PRINT           shift and go to state 47
    READ            shift and go to state 45
    ID              shift and go to state 56
    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11

    vars                           shift and go to state 44
    array                          shift and go to state 48
    write                          shift and go to state 49
    call                           shift and go to state 51
    statement                      shift and go to state 52
    type                           shift and go to state 13
    empty                          shift and go to state 53
    read                           shift and go to state 50
    assignment                     shift and go to state 54
    assignmentaux                  shift and go to state 55
    condition                      shift and go to state 57
    blockneutral                   shift and go to state 172
    loop                           shift and go to state 60

state 159

    (72) function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn . codeScope
    (88) codeScope -> .

    FUNCTION        reduce using rule 88 (codeScope -> .)
    INT             reduce using rule 88 (codeScope -> .)
    FLOAT           reduce using rule 88 (codeScope -> .)
    CHAR            reduce using rule 88 (codeScope -> .)
    BOOL            reduce using rule 88 (codeScope -> .)
    STRING          reduce using rule 88 (codeScope -> .)
    PRIOMH          reduce using rule 88 (codeScope -> .)

    codeScope                      shift and go to state 173

state 160

    (84) read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .

    IF              reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    READ            reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    ID              reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    INT             reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    STRING          reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 84 (read -> READ LFTPAREN readaux RGTPAREN SEMICOLON .)


state 161

    (51) loop -> WHILE LFTPAREN expression RGTPAREN block .

    IF              reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    WHILE           reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    PRINT           reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    READ            reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    ID              reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    INT             reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    FLOAT           reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    CHAR            reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    BOOL            reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    STRING          reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    RGTBRAC         reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    RETURN          reduce using rule 51 (loop -> WHILE LFTPAREN expression RGTPAREN block .)


state 162

    (52) write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .

    IF              reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    READ            reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    ID              reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    INT             reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    STRING          reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 52 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)


state 163

    (80) call -> ID LFTPAREN exp callaux RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 174


state 164

    (81) callaux -> COMMA exp . callaux
    (81) callaux -> . COMMA exp callaux
    (82) callaux -> . empty
    (87) empty -> .

    COMMA           shift and go to state 145
    RGTPAREN        reduce using rule 87 (empty -> .)

    empty                          shift and go to state 146
    callaux                        shift and go to state 175

state 165

    (20) conditionaux -> LFTPAREN expression RGTPAREN block . conditionaux2
    (21) conditionaux2 -> . ELSEIF conditionaux
    (22) conditionaux2 -> . empty
    (87) empty -> .

    ELSEIF          shift and go to state 178
    ELSE            reduce using rule 87 (empty -> .)
    IF              reduce using rule 87 (empty -> .)
    WHILE           reduce using rule 87 (empty -> .)
    PRINT           reduce using rule 87 (empty -> .)
    READ            reduce using rule 87 (empty -> .)
    ID              reduce using rule 87 (empty -> .)
    INT             reduce using rule 87 (empty -> .)
    FLOAT           reduce using rule 87 (empty -> .)
    CHAR            reduce using rule 87 (empty -> .)
    BOOL            reduce using rule 87 (empty -> .)
    STRING          reduce using rule 87 (empty -> .)
    RGTBRAC         reduce using rule 87 (empty -> .)
    RETURN          reduce using rule 87 (empty -> .)

    empty                          shift and go to state 177
    conditionaux2                  shift and go to state 176

state 166

    (7) arrayvaluesaux -> constant .
    (8) arrayvaluesaux -> constant . COMMA arrayvaluesaux

    RGTBRACSQR      reduce using rule 7 (arrayvaluesaux -> constant .)
    COMMA           shift and go to state 179


state 167

    (6) arrayvalues -> LFTBRACSQR arrayvaluesaux . RGTBRACSQR

    RGTBRACSQR      shift and go to state 180


state 168

    (78) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .

    FUNCTION        reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    INT             reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    FLOAT           reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    CHAR            reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    BOOL            reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    STRING          reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    PRIOMH          reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    IF              reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    WHILE           reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    PRINT           reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    READ            reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    ID              reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    RGTBRAC         reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)
    RETURN          reduce using rule 78 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON .)


state 169

    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA . varsaux
    (76) varsaux -> . ID codeAddVar EQUAL expression SEMICOLON
    (77) varsaux -> . ID codeAddVar EQUAL expression COMMA varsaux
    (78) varsaux -> . ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues SEMICOLON
    (79) varsaux -> . ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux

    ID              shift and go to state 24

    varsaux                        shift and go to state 181

state 170

    (83) call2 -> ID LFTPAREN exp callaux RGTPAREN .

    MULTIPLICATION  reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    DIVISION        reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    PLUS            reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    MINUS           reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    RGTBRACSQR      reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    AND             reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    DOUBEQUAL       reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    NOT             reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    OR              reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    LESSTHANEQUAL   reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    GREATTHANEQUAL  reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    GREATTHAN       reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    LESSTHAN        reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    SEMICOLON       reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    COMMA           reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)
    RGTPAREN        reduce using rule 83 (call2 -> ID LFTPAREN exp callaux RGTPAREN .)


state 171

    (54) parameter -> type ID codeAddParameters COMMA . parameter
    (53) parameter -> . type ID codeAddParameters
    (54) parameter -> . type ID codeAddParameters COMMA parameter
    (55) parameter -> . empty
    (66) type -> . INT checkType
    (67) type -> . FLOAT checkType
    (68) type -> . CHAR checkType
    (69) type -> . BOOL checkType
    (70) type -> . STRING checkType
    (87) empty -> .

    INT             shift and go to state 12
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 11
    RGTPAREN        reduce using rule 87 (empty -> .)

    parameter                      shift and go to state 182
    type                           shift and go to state 116
    empty                          shift and go to state 118

state 172

    (12) blockreturn -> LFTBRAC blockneutral . RGTBRAC
    (13) blockreturn -> LFTBRAC blockneutral . RETURN exp SEMICOLON RGTBRAC

    RGTBRAC         shift and go to state 184
    RETURN          shift and go to state 183


state 173

    (72) function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .

    FUNCTION        reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)
    INT             reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)
    FLOAT           reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)
    CHAR            reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)
    BOOL            reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)
    STRING          reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)
    PRIOMH          reduce using rule 72 (function -> FUNCTION codeScope functionaux ID codeNameOfFunct LFTPAREN parameter RGTPAREN blockreturn codeScope .)


state 174

    (80) call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .

    IF              reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    READ            reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    ID              reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    INT             reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    STRING          reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 80 (call -> ID LFTPAREN exp callaux RGTPAREN SEMICOLON .)


state 175

    (81) callaux -> COMMA exp callaux .

    RGTPAREN        reduce using rule 81 (callaux -> COMMA exp callaux .)


state 176

    (20) conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .

    ELSE            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    IF              reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    WHILE           reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    PRINT           reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    READ            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    ID              reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    INT             reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    FLOAT           reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    CHAR            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    BOOL            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    STRING          reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    RGTBRAC         reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)
    RETURN          reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block conditionaux2 .)


state 177

    (22) conditionaux2 -> empty .

    ELSE            reduce using rule 22 (conditionaux2 -> empty .)
    IF              reduce using rule 22 (conditionaux2 -> empty .)
    WHILE           reduce using rule 22 (conditionaux2 -> empty .)
    PRINT           reduce using rule 22 (conditionaux2 -> empty .)
    READ            reduce using rule 22 (conditionaux2 -> empty .)
    ID              reduce using rule 22 (conditionaux2 -> empty .)
    INT             reduce using rule 22 (conditionaux2 -> empty .)
    FLOAT           reduce using rule 22 (conditionaux2 -> empty .)
    CHAR            reduce using rule 22 (conditionaux2 -> empty .)
    BOOL            reduce using rule 22 (conditionaux2 -> empty .)
    STRING          reduce using rule 22 (conditionaux2 -> empty .)
    RGTBRAC         reduce using rule 22 (conditionaux2 -> empty .)
    RETURN          reduce using rule 22 (conditionaux2 -> empty .)


state 178

    (21) conditionaux2 -> ELSEIF . conditionaux
    (20) conditionaux -> . LFTPAREN expression RGTPAREN block conditionaux2

    LFTPAREN        shift and go to state 89

    conditionaux                   shift and go to state 185

state 179

    (8) arrayvaluesaux -> constant COMMA . arrayvaluesaux
    (7) arrayvaluesaux -> . constant
    (8) arrayvaluesaux -> . constant COMMA arrayvaluesaux
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    constant                       shift and go to state 166
    call2                          shift and go to state 67
    array                          shift and go to state 64
    cteN                           shift and go to state 65
    arrayvaluesaux                 shift and go to state 186

state 180

    (6) arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR .

    SEMICOLON       reduce using rule 6 (arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR .)
    COMMA           reduce using rule 6 (arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR .)


state 181

    (79) varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .

    FUNCTION        reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    INT             reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    FLOAT           reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    CHAR            reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    BOOL            reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    STRING          reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    PRIOMH          reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    IF              reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    WHILE           reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    PRINT           reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    READ            reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    ID              reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    RGTBRAC         reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)
    RETURN          reduce using rule 79 (varsaux -> ID codeAddVarArreglo LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux .)


state 182

    (54) parameter -> type ID codeAddParameters COMMA parameter .

    RGTPAREN        reduce using rule 54 (parameter -> type ID codeAddParameters COMMA parameter .)


state 183

    (13) blockreturn -> LFTBRAC blockneutral RETURN . exp SEMICOLON RGTBRAC
    (33) exp -> . term expaux
    (56) term -> . factor termaux
    (37) factor -> . LFTPAREN expression RGTPAREN
    (38) factor -> . constant
    (39) factor -> . MINUS constant
    (40) factor -> . PLUS constant
    (23) constant -> . ID
    (24) constant -> . array
    (25) constant -> . cteN
    (26) constant -> . cteS
    (27) constant -> . TRUE
    (28) constant -> . FALSE
    (29) constant -> . call2
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (30) cteN -> . FLOAT
    (31) cteN -> . INT
    (32) cteS -> . STRING
    (83) call2 -> . ID LFTPAREN exp callaux RGTPAREN

    LFTPAREN        shift and go to state 72
    MINUS           shift and go to state 66
    PLUS            shift and go to state 70
    ID              shift and go to state 73
    TRUE            shift and go to state 68
    FALSE           shift and go to state 75
    FLOAT           shift and go to state 77
    INT             shift and go to state 76
    STRING          shift and go to state 71

    cteS                           shift and go to state 63
    term                           shift and go to state 74
    constant                       shift and go to state 62
    call2                          shift and go to state 67
    cteN                           shift and go to state 65
    exp                            shift and go to state 187
    factor                         shift and go to state 69
    array                          shift and go to state 64

state 184

    (12) blockreturn -> LFTBRAC blockneutral RGTBRAC .

    FUNCTION        reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)
    INT             reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)
    FLOAT           reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)
    CHAR            reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)
    BOOL            reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)
    STRING          reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)
    PRIOMH          reduce using rule 12 (blockreturn -> LFTBRAC blockneutral RGTBRAC .)


state 185

    (21) conditionaux2 -> ELSEIF conditionaux .

    ELSE            reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    IF              reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    WHILE           reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    PRINT           reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    READ            reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    ID              reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    INT             reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    FLOAT           reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    CHAR            reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    BOOL            reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    STRING          reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    RGTBRAC         reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)
    RETURN          reduce using rule 21 (conditionaux2 -> ELSEIF conditionaux .)


state 186

    (8) arrayvaluesaux -> constant COMMA arrayvaluesaux .

    RGTBRACSQR      reduce using rule 8 (arrayvaluesaux -> constant COMMA arrayvaluesaux .)


state 187

    (13) blockreturn -> LFTBRAC blockneutral RETURN exp . SEMICOLON RGTBRAC

    SEMICOLON       shift and go to state 188


state 188

    (13) blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON . RGTBRAC

    RGTBRAC         shift and go to state 189


state 189

    (13) blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .

    FUNCTION        reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)
    INT             reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)
    FLOAT           reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)
    CHAR            reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)
    BOOL            reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)
    STRING          reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)
    PRIOMH          reduce using rule 13 (blockreturn -> LFTBRAC blockneutral RETURN exp SEMICOLON RGTBRAC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MULTIPLICATION in state 69 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 74 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 130 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 130 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
