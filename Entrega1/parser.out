Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    WRITE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC
Rule 2     auxprogram -> vars auxprogram
Rule 3     auxprogram -> function auxprogram
Rule 4     auxprogram -> empty
Rule 5     array -> ID LFTBRACSQR exp RGTBRACSQR
Rule 6     assignment -> assignmentaux EQUAL expression SEMICOLON
Rule 7     assignment -> assignmentaux EQUAL call SEMICOLON
Rule 8     assignmentaux -> ID
Rule 9     assignmentaux -> array
Rule 10    blockreturn -> LFTBRAC blockreturnaux RGTBRAC
Rule 11    blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC
Rule 12    blockreturnaux -> statement blockreturnaux
Rule 13    blockreturnaux -> empty
Rule 14    block -> LFTBRAC blockaux RGTBRAC
Rule 15    blockaux -> statement blockaux
Rule 16    blockaux -> empty
Rule 17    condition -> IF conditionaux
Rule 18    condition -> IF conditionaux ELSE block
Rule 19    conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux
Rule 20    conditionaux -> LFTPAREN expression RGTPAREN block
Rule 21    constant -> ID
Rule 22    constant -> array
Rule 23    constant -> cteN
Rule 24    constant -> cteS
Rule 25    constant -> TRUE
Rule 26    constant -> FALSE
Rule 27    cteN -> FLOAT
Rule 28    cteN -> INT
Rule 29    cteS -> STRING
Rule 30    exp -> term
Rule 31    exp -> term expaux
Rule 32    expaux -> PLUS exp expaux
Rule 33    expaux -> MINUS exp expaux
Rule 34    expaux -> empty
Rule 35    factor -> factoraux constant
Rule 36    factor -> LFTPAREN expression RGTPAREN
Rule 37    factoraux -> PLUS
Rule 38    factoraux -> MINUS
Rule 39    expression -> exp
Rule 40    expression -> exp expressionaux exp
Rule 41    expressionaux -> AND
Rule 42    expressionaux -> DOUBEQUAL
Rule 43    expressionaux -> NOT
Rule 44    expressionaux -> OR
Rule 45    expressionaux -> LESSTHANEQUAL
Rule 46    expressionaux -> GREATTHANEQUAL
Rule 47    expressionaux -> GREATTHAN
Rule 48    expressionaux -> LESSTHAN
Rule 49    loop -> WHILE LFTPAREN expression RGTPAREN block
Rule 50    write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON
Rule 51    parameter -> type ID
Rule 52    parameter -> type ID COMMA parameter
Rule 53    parameter -> empty
Rule 54    term -> factor termaux
Rule 55    termaux -> MULTIPLICATION term termaux
Rule 56    termaux -> DIVISION term termaux
Rule 57    termaux -> empty
Rule 58    statement -> assignment
Rule 59    statement -> condition
Rule 60    statement -> vars
Rule 61    statement -> loop
Rule 62    statement -> write
Rule 63    statement -> read
Rule 64    statement -> call
Rule 65    type -> INT
Rule 66    type -> FLOAT
Rule 67    type -> CHAR
Rule 68    type -> BOOL
Rule 69    type -> STRING
Rule 70    main -> PRIOMH block
Rule 71    function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
Rule 72    functionaux -> VOID
Rule 73    functionaux -> type
Rule 74    functionaux2 -> parameter
Rule 75    functionaux2 -> empty
Rule 76    vars -> type varsaux2 SEMICOLON
Rule 77    varsaux -> PLUS
Rule 78    varsaux -> MINUS
Rule 79    varsaux -> empty
Rule 80    varsaux2 -> ID EQUAL varsaux constant
Rule 81    varsaux2 -> ID EQUAL varsaux constant COMMA varsaux2
Rule 82    call -> ID LFTPAREN exp RGTPAREN SEMICOLON
Rule 83    call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
Rule 84    read -> READ LFTPAREN ID RGTPAREN SEMICOLON
Rule 85    empty -> <empty>

Terminals, with rules where they appear

AND                  : 41
ARRAY                : 
BOOL                 : 68
CHAR                 : 67
COMMA                : 52 81 83
DIVISION             : 56
DOUBEQUAL            : 42
ELSE                 : 18
ELSEIF               : 19
EQUAL                : 6 7 80 81
FALSE                : 26
FLOAT                : 27 66
FUNCTION             : 71
GREATTHAN            : 47
GREATTHANEQUAL       : 46
ID                   : 1 5 8 21 51 52 71 80 81 82 83 84
IF                   : 17 18
INT                  : 28 65
LESSTHAN             : 48
LESSTHANEQUAL        : 45
LFTBRAC              : 1 10 11 14
LFTBRACSQR           : 5
LFTPAREN             : 19 20 36 49 50 71 82 83 84
MINUS                : 33 38 78
MULTIPLICATION       : 55
NOT                  : 43
OR                   : 44
PLUS                 : 32 37 77
PRINT                : 50
PRIOMH               : 70
PROGRAM              : 1
READ                 : 84
RETURN               : 11
RGTBRAC              : 1 10 11 14
RGTBRACSQR           : 5
RGTPAREN             : 19 20 36 49 50 71 82 83 84
SEMICOLON            : 6 7 11 50 76 82 83 84
STRING               : 29 69
TRUE                 : 25
VOID                 : 72
WHILE                : 49
WRITE                : 
error                : 

Nonterminals, with rules where they appear

array                : 9 22
assignment           : 58
assignmentaux        : 6 7
auxprogram           : 1 2 3
block                : 18 19 20 49 70
blockaux             : 14 15
blockreturn          : 71
blockreturnaux       : 10 11 12
call                 : 7 64 83
condition            : 59
conditionaux         : 17 18 19
constant             : 35 50 80 81
cteN                 : 23
cteS                 : 24
empty                : 4 13 16 34 53 57 75 79
exp                  : 5 11 32 33 39 40 40 82 83
expaux               : 31 32 33
expression           : 6 19 20 36 49
expressionaux        : 40
factor               : 54
factoraux            : 35
function             : 3
functionaux          : 71
functionaux2         : 71
loop                 : 61
main                 : 1
parameter            : 52 74
program              : 0
read                 : 63
statement            : 12 15
term                 : 30 31 55 56
termaux              : 54 55 56
type                 : 51 52 73 76
vars                 : 2 60
varsaux              : 80 81
varsaux2             : 76 81
write                : 62

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID LFTBRAC auxprogram main RGTBRAC

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID LFTBRAC auxprogram main RGTBRAC

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . LFTBRAC auxprogram main RGTBRAC

    LFTBRAC         shift and go to state 4


state 4

    (1) program -> PROGRAM ID LFTBRAC . auxprogram main RGTBRAC
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (76) vars -> . type varsaux2 SEMICOLON
    (71) function -> . FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (85) empty -> .
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 85 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    function                       shift and go to state 11
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 5

    (71) function -> FUNCTION . functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (72) functionaux -> . VOID
    (73) functionaux -> . type
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING

    VOID            shift and go to state 16
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    functionaux                    shift and go to state 17
    type                           shift and go to state 18

state 6

    (2) auxprogram -> vars . auxprogram
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (76) vars -> . type varsaux2 SEMICOLON
    (71) function -> . FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (85) empty -> .
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 85 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    function                       shift and go to state 11
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 19
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 7

    (67) type -> CHAR .

    ID              reduce using rule 67 (type -> CHAR .)


state 8

    (1) program -> PROGRAM ID LFTBRAC auxprogram . main RGTBRAC
    (70) main -> . PRIOMH block

    PRIOMH          shift and go to state 20

    main                           shift and go to state 21

state 9

    (76) vars -> type . varsaux2 SEMICOLON
    (80) varsaux2 -> . ID EQUAL varsaux constant
    (81) varsaux2 -> . ID EQUAL varsaux constant COMMA varsaux2

    ID              shift and go to state 23

    varsaux2                       shift and go to state 22

state 10

    (4) auxprogram -> empty .

    PRIOMH          reduce using rule 4 (auxprogram -> empty .)


state 11

    (3) auxprogram -> function . auxprogram
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (76) vars -> . type varsaux2 SEMICOLON
    (71) function -> . FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (85) empty -> .
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 85 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    function                       shift and go to state 11
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 24
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 12

    (69) type -> STRING .

    ID              reduce using rule 69 (type -> STRING .)


state 13

    (65) type -> INT .

    ID              reduce using rule 65 (type -> INT .)


state 14

    (66) type -> FLOAT .

    ID              reduce using rule 66 (type -> FLOAT .)


state 15

    (68) type -> BOOL .

    ID              reduce using rule 68 (type -> BOOL .)


state 16

    (72) functionaux -> VOID .

    ID              reduce using rule 72 (functionaux -> VOID .)


state 17

    (71) function -> FUNCTION functionaux . ID LFTPAREN functionaux2 RGTPAREN blockreturn

    ID              shift and go to state 25


state 18

    (73) functionaux -> type .

    ID              reduce using rule 73 (functionaux -> type .)


state 19

    (2) auxprogram -> vars auxprogram .

    PRIOMH          reduce using rule 2 (auxprogram -> vars auxprogram .)


state 20

    (70) main -> PRIOMH . block
    (14) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 27

state 21

    (1) program -> PROGRAM ID LFTBRAC auxprogram main . RGTBRAC

    RGTBRAC         shift and go to state 28


state 22

    (76) vars -> type varsaux2 . SEMICOLON

    SEMICOLON       shift and go to state 29


state 23

    (80) varsaux2 -> ID . EQUAL varsaux constant
    (81) varsaux2 -> ID . EQUAL varsaux constant COMMA varsaux2

    EQUAL           shift and go to state 30


state 24

    (3) auxprogram -> function auxprogram .

    PRIOMH          reduce using rule 3 (auxprogram -> function auxprogram .)


state 25

    (71) function -> FUNCTION functionaux ID . LFTPAREN functionaux2 RGTPAREN blockreturn

    LFTPAREN        shift and go to state 31


state 26

    (14) block -> LFTBRAC . blockaux RGTBRAC
    (15) blockaux -> . statement blockaux
    (16) blockaux -> . empty
    (58) statement -> . assignment
    (59) statement -> . condition
    (60) statement -> . vars
    (61) statement -> . loop
    (62) statement -> . write
    (63) statement -> . read
    (64) statement -> . call
    (85) empty -> .
    (6) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (7) assignment -> . assignmentaux EQUAL call SEMICOLON
    (17) condition -> . IF conditionaux
    (18) condition -> . IF conditionaux ELSE block
    (76) vars -> . type varsaux2 SEMICOLON
    (49) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (50) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (82) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (8) assignmentaux -> . ID
    (9) assignmentaux -> . array
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 85 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 34
    PRINT           shift and go to state 35
    READ            shift and go to state 33
    ID              shift and go to state 45
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    type                           shift and go to state 9
    vars                           shift and go to state 32
    read                           shift and go to state 38
    assignment                     shift and go to state 43
    write                          shift and go to state 37
    assignmentaux                  shift and go to state 44
    call                           shift and go to state 39
    empty                          shift and go to state 41
    statement                      shift and go to state 40
    loop                           shift and go to state 48
    array                          shift and go to state 36
    condition                      shift and go to state 46
    blockaux                       shift and go to state 42

state 27

    (70) main -> PRIOMH block .

    RGTBRAC         reduce using rule 70 (main -> PRIOMH block .)


state 28

    (1) program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC .

    $end            reduce using rule 1 (program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC .)


state 29

    (76) vars -> type varsaux2 SEMICOLON .

    IF              reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    WHILE           reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    PRINT           reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    READ            reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    ID              reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    INT             reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    FLOAT           reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    CHAR            reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    BOOL            reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    STRING          reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    RGTBRAC         reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    RETURN          reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    FUNCTION        reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)
    PRIOMH          reduce using rule 76 (vars -> type varsaux2 SEMICOLON .)


state 30

    (80) varsaux2 -> ID EQUAL . varsaux constant
    (81) varsaux2 -> ID EQUAL . varsaux constant COMMA varsaux2
    (77) varsaux -> . PLUS
    (78) varsaux -> . MINUS
    (79) varsaux -> . empty
    (85) empty -> .

    PLUS            shift and go to state 50
    MINUS           shift and go to state 49
    ID              reduce using rule 85 (empty -> .)
    TRUE            reduce using rule 85 (empty -> .)
    FALSE           reduce using rule 85 (empty -> .)
    FLOAT           reduce using rule 85 (empty -> .)
    INT             reduce using rule 85 (empty -> .)
    STRING          reduce using rule 85 (empty -> .)

    empty                          shift and go to state 51
    varsaux                        shift and go to state 52

state 31

    (71) function -> FUNCTION functionaux ID LFTPAREN . functionaux2 RGTPAREN blockreturn
    (74) functionaux2 -> . parameter
    (75) functionaux2 -> . empty
    (51) parameter -> . type ID
    (52) parameter -> . type ID COMMA parameter
    (53) parameter -> . empty
    (85) empty -> .
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING

    RGTPAREN        reduce using rule 85 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    type                           shift and go to state 53
    functionaux2                   shift and go to state 54
    parameter                      shift and go to state 55
    empty                          shift and go to state 56

state 32

    (60) statement -> vars .

    IF              reduce using rule 60 (statement -> vars .)
    WHILE           reduce using rule 60 (statement -> vars .)
    PRINT           reduce using rule 60 (statement -> vars .)
    READ            reduce using rule 60 (statement -> vars .)
    ID              reduce using rule 60 (statement -> vars .)
    INT             reduce using rule 60 (statement -> vars .)
    FLOAT           reduce using rule 60 (statement -> vars .)
    CHAR            reduce using rule 60 (statement -> vars .)
    BOOL            reduce using rule 60 (statement -> vars .)
    STRING          reduce using rule 60 (statement -> vars .)
    RGTBRAC         reduce using rule 60 (statement -> vars .)
    RETURN          reduce using rule 60 (statement -> vars .)


state 33

    (84) read -> READ . LFTPAREN ID RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 57


state 34

    (49) loop -> WHILE . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 58


state 35

    (50) write -> PRINT . LFTPAREN constant RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 59


state 36

    (9) assignmentaux -> array .

    EQUAL           reduce using rule 9 (assignmentaux -> array .)


state 37

    (62) statement -> write .

    IF              reduce using rule 62 (statement -> write .)
    WHILE           reduce using rule 62 (statement -> write .)
    PRINT           reduce using rule 62 (statement -> write .)
    READ            reduce using rule 62 (statement -> write .)
    ID              reduce using rule 62 (statement -> write .)
    INT             reduce using rule 62 (statement -> write .)
    FLOAT           reduce using rule 62 (statement -> write .)
    CHAR            reduce using rule 62 (statement -> write .)
    BOOL            reduce using rule 62 (statement -> write .)
    STRING          reduce using rule 62 (statement -> write .)
    RGTBRAC         reduce using rule 62 (statement -> write .)
    RETURN          reduce using rule 62 (statement -> write .)


state 38

    (63) statement -> read .

    IF              reduce using rule 63 (statement -> read .)
    WHILE           reduce using rule 63 (statement -> read .)
    PRINT           reduce using rule 63 (statement -> read .)
    READ            reduce using rule 63 (statement -> read .)
    ID              reduce using rule 63 (statement -> read .)
    INT             reduce using rule 63 (statement -> read .)
    FLOAT           reduce using rule 63 (statement -> read .)
    CHAR            reduce using rule 63 (statement -> read .)
    BOOL            reduce using rule 63 (statement -> read .)
    STRING          reduce using rule 63 (statement -> read .)
    RGTBRAC         reduce using rule 63 (statement -> read .)
    RETURN          reduce using rule 63 (statement -> read .)


state 39

    (64) statement -> call .

    IF              reduce using rule 64 (statement -> call .)
    WHILE           reduce using rule 64 (statement -> call .)
    PRINT           reduce using rule 64 (statement -> call .)
    READ            reduce using rule 64 (statement -> call .)
    ID              reduce using rule 64 (statement -> call .)
    INT             reduce using rule 64 (statement -> call .)
    FLOAT           reduce using rule 64 (statement -> call .)
    CHAR            reduce using rule 64 (statement -> call .)
    BOOL            reduce using rule 64 (statement -> call .)
    STRING          reduce using rule 64 (statement -> call .)
    RGTBRAC         reduce using rule 64 (statement -> call .)
    RETURN          reduce using rule 64 (statement -> call .)


state 40

    (15) blockaux -> statement . blockaux
    (15) blockaux -> . statement blockaux
    (16) blockaux -> . empty
    (58) statement -> . assignment
    (59) statement -> . condition
    (60) statement -> . vars
    (61) statement -> . loop
    (62) statement -> . write
    (63) statement -> . read
    (64) statement -> . call
    (85) empty -> .
    (6) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (7) assignment -> . assignmentaux EQUAL call SEMICOLON
    (17) condition -> . IF conditionaux
    (18) condition -> . IF conditionaux ELSE block
    (76) vars -> . type varsaux2 SEMICOLON
    (49) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (50) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (82) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (8) assignmentaux -> . ID
    (9) assignmentaux -> . array
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 85 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 34
    PRINT           shift and go to state 35
    READ            shift and go to state 33
    ID              shift and go to state 45
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    type                           shift and go to state 9
    vars                           shift and go to state 32
    read                           shift and go to state 38
    assignment                     shift and go to state 43
    write                          shift and go to state 37
    assignmentaux                  shift and go to state 44
    call                           shift and go to state 39
    empty                          shift and go to state 41
    statement                      shift and go to state 40
    loop                           shift and go to state 48
    array                          shift and go to state 36
    condition                      shift and go to state 46
    blockaux                       shift and go to state 60

state 41

    (16) blockaux -> empty .

    RGTBRAC         reduce using rule 16 (blockaux -> empty .)


state 42

    (14) block -> LFTBRAC blockaux . RGTBRAC

    RGTBRAC         shift and go to state 61


state 43

    (58) statement -> assignment .

    IF              reduce using rule 58 (statement -> assignment .)
    WHILE           reduce using rule 58 (statement -> assignment .)
    PRINT           reduce using rule 58 (statement -> assignment .)
    READ            reduce using rule 58 (statement -> assignment .)
    ID              reduce using rule 58 (statement -> assignment .)
    INT             reduce using rule 58 (statement -> assignment .)
    FLOAT           reduce using rule 58 (statement -> assignment .)
    CHAR            reduce using rule 58 (statement -> assignment .)
    BOOL            reduce using rule 58 (statement -> assignment .)
    STRING          reduce using rule 58 (statement -> assignment .)
    RGTBRAC         reduce using rule 58 (statement -> assignment .)
    RETURN          reduce using rule 58 (statement -> assignment .)


state 44

    (6) assignment -> assignmentaux . EQUAL expression SEMICOLON
    (7) assignment -> assignmentaux . EQUAL call SEMICOLON

    EQUAL           shift and go to state 62


state 45

    (82) call -> ID . LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> ID . LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (8) assignmentaux -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR

    LFTPAREN        shift and go to state 63
    EQUAL           reduce using rule 8 (assignmentaux -> ID .)
    LFTBRACSQR      shift and go to state 64


state 46

    (59) statement -> condition .

    IF              reduce using rule 59 (statement -> condition .)
    WHILE           reduce using rule 59 (statement -> condition .)
    PRINT           reduce using rule 59 (statement -> condition .)
    READ            reduce using rule 59 (statement -> condition .)
    ID              reduce using rule 59 (statement -> condition .)
    INT             reduce using rule 59 (statement -> condition .)
    FLOAT           reduce using rule 59 (statement -> condition .)
    CHAR            reduce using rule 59 (statement -> condition .)
    BOOL            reduce using rule 59 (statement -> condition .)
    STRING          reduce using rule 59 (statement -> condition .)
    RGTBRAC         reduce using rule 59 (statement -> condition .)
    RETURN          reduce using rule 59 (statement -> condition .)


state 47

    (17) condition -> IF . conditionaux
    (18) condition -> IF . conditionaux ELSE block
    (19) conditionaux -> . LFTPAREN expression RGTPAREN block ELSEIF conditionaux
    (20) conditionaux -> . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 65

    conditionaux                   shift and go to state 66

state 48

    (61) statement -> loop .

    IF              reduce using rule 61 (statement -> loop .)
    WHILE           reduce using rule 61 (statement -> loop .)
    PRINT           reduce using rule 61 (statement -> loop .)
    READ            reduce using rule 61 (statement -> loop .)
    ID              reduce using rule 61 (statement -> loop .)
    INT             reduce using rule 61 (statement -> loop .)
    FLOAT           reduce using rule 61 (statement -> loop .)
    CHAR            reduce using rule 61 (statement -> loop .)
    BOOL            reduce using rule 61 (statement -> loop .)
    STRING          reduce using rule 61 (statement -> loop .)
    RGTBRAC         reduce using rule 61 (statement -> loop .)
    RETURN          reduce using rule 61 (statement -> loop .)


state 49

    (78) varsaux -> MINUS .

    ID              reduce using rule 78 (varsaux -> MINUS .)
    TRUE            reduce using rule 78 (varsaux -> MINUS .)
    FALSE           reduce using rule 78 (varsaux -> MINUS .)
    FLOAT           reduce using rule 78 (varsaux -> MINUS .)
    INT             reduce using rule 78 (varsaux -> MINUS .)
    STRING          reduce using rule 78 (varsaux -> MINUS .)


state 50

    (77) varsaux -> PLUS .

    ID              reduce using rule 77 (varsaux -> PLUS .)
    TRUE            reduce using rule 77 (varsaux -> PLUS .)
    FALSE           reduce using rule 77 (varsaux -> PLUS .)
    FLOAT           reduce using rule 77 (varsaux -> PLUS .)
    INT             reduce using rule 77 (varsaux -> PLUS .)
    STRING          reduce using rule 77 (varsaux -> PLUS .)


state 51

    (79) varsaux -> empty .

    ID              reduce using rule 79 (varsaux -> empty .)
    TRUE            reduce using rule 79 (varsaux -> empty .)
    FALSE           reduce using rule 79 (varsaux -> empty .)
    FLOAT           reduce using rule 79 (varsaux -> empty .)
    INT             reduce using rule 79 (varsaux -> empty .)
    STRING          reduce using rule 79 (varsaux -> empty .)


state 52

    (80) varsaux2 -> ID EQUAL varsaux . constant
    (81) varsaux2 -> ID EQUAL varsaux . constant COMMA varsaux2
    (21) constant -> . ID
    (22) constant -> . array
    (23) constant -> . cteN
    (24) constant -> . cteS
    (25) constant -> . TRUE
    (26) constant -> . FALSE
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (27) cteN -> . FLOAT
    (28) cteN -> . INT
    (29) cteS -> . STRING

    ID              shift and go to state 76
    TRUE            shift and go to state 71
    FALSE           shift and go to state 73
    FLOAT           shift and go to state 72
    INT             shift and go to state 70
    STRING          shift and go to state 69

    cteS                           shift and go to state 67
    constant                       shift and go to state 68
    array                          shift and go to state 74
    cteN                           shift and go to state 75

state 53

    (51) parameter -> type . ID
    (52) parameter -> type . ID COMMA parameter

    ID              shift and go to state 77


state 54

    (71) function -> FUNCTION functionaux ID LFTPAREN functionaux2 . RGTPAREN blockreturn

    RGTPAREN        shift and go to state 78


state 55

    (74) functionaux2 -> parameter .

    RGTPAREN        reduce using rule 74 (functionaux2 -> parameter .)


state 56

    (75) functionaux2 -> empty .
    (53) parameter -> empty .

  ! reduce/reduce conflict for RGTPAREN resolved using rule 53 (parameter -> empty .)
    RGTPAREN        reduce using rule 53 (parameter -> empty .)

  ! RGTPAREN        [ reduce using rule 75 (functionaux2 -> empty .) ]


state 57

    (84) read -> READ LFTPAREN . ID RGTPAREN SEMICOLON

    ID              shift and go to state 79


state 58

    (49) loop -> WHILE LFTPAREN . expression RGTPAREN block
    (39) expression -> . exp
    (40) expression -> . exp expressionaux exp
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 83
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85
    expression                     shift and go to state 86

state 59

    (50) write -> PRINT LFTPAREN . constant RGTPAREN SEMICOLON
    (21) constant -> . ID
    (22) constant -> . array
    (23) constant -> . cteN
    (24) constant -> . cteS
    (25) constant -> . TRUE
    (26) constant -> . FALSE
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (27) cteN -> . FLOAT
    (28) cteN -> . INT
    (29) cteS -> . STRING

    ID              shift and go to state 76
    TRUE            shift and go to state 71
    FALSE           shift and go to state 73
    FLOAT           shift and go to state 72
    INT             shift and go to state 70
    STRING          shift and go to state 69

    cteN                           shift and go to state 75
    array                          shift and go to state 74
    constant                       shift and go to state 88
    cteS                           shift and go to state 67

state 60

    (15) blockaux -> statement blockaux .

    RGTBRAC         reduce using rule 15 (blockaux -> statement blockaux .)


state 61

    (14) block -> LFTBRAC blockaux RGTBRAC .

    ELSEIF          reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    ELSE            reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    IF              reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    WHILE           reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    PRINT           reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    READ            reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    ID              reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    INT             reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    FLOAT           reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    CHAR            reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    BOOL            reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    STRING          reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    RGTBRAC         reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)
    RETURN          reduce using rule 14 (block -> LFTBRAC blockaux RGTBRAC .)


state 62

    (6) assignment -> assignmentaux EQUAL . expression SEMICOLON
    (7) assignment -> assignmentaux EQUAL . call SEMICOLON
    (39) expression -> . exp
    (40) expression -> . exp expressionaux exp
    (82) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    ID              shift and go to state 91
    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    call                           shift and go to state 89
    exp                            shift and go to state 83
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85
    expression                     shift and go to state 90

state 63

    (82) call -> ID LFTPAREN . exp RGTPAREN SEMICOLON
    (83) call -> ID LFTPAREN . exp COMMA call RGTPAREN SEMICOLON
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 92
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 64

    (5) array -> ID LFTBRACSQR . exp RGTBRACSQR
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 93
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 65

    (19) conditionaux -> LFTPAREN . expression RGTPAREN block ELSEIF conditionaux
    (20) conditionaux -> LFTPAREN . expression RGTPAREN block
    (39) expression -> . exp
    (40) expression -> . exp expressionaux exp
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 83
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85
    expression                     shift and go to state 94

state 66

    (17) condition -> IF conditionaux .
    (18) condition -> IF conditionaux . ELSE block

    IF              reduce using rule 17 (condition -> IF conditionaux .)
    WHILE           reduce using rule 17 (condition -> IF conditionaux .)
    PRINT           reduce using rule 17 (condition -> IF conditionaux .)
    READ            reduce using rule 17 (condition -> IF conditionaux .)
    ID              reduce using rule 17 (condition -> IF conditionaux .)
    INT             reduce using rule 17 (condition -> IF conditionaux .)
    FLOAT           reduce using rule 17 (condition -> IF conditionaux .)
    CHAR            reduce using rule 17 (condition -> IF conditionaux .)
    BOOL            reduce using rule 17 (condition -> IF conditionaux .)
    STRING          reduce using rule 17 (condition -> IF conditionaux .)
    RGTBRAC         reduce using rule 17 (condition -> IF conditionaux .)
    RETURN          reduce using rule 17 (condition -> IF conditionaux .)
    ELSE            shift and go to state 95


state 67

    (24) constant -> cteS .

    MULTIPLICATION  reduce using rule 24 (constant -> cteS .)
    DIVISION        reduce using rule 24 (constant -> cteS .)
    PLUS            reduce using rule 24 (constant -> cteS .)
    MINUS           reduce using rule 24 (constant -> cteS .)
    AND             reduce using rule 24 (constant -> cteS .)
    DOUBEQUAL       reduce using rule 24 (constant -> cteS .)
    NOT             reduce using rule 24 (constant -> cteS .)
    OR              reduce using rule 24 (constant -> cteS .)
    LESSTHANEQUAL   reduce using rule 24 (constant -> cteS .)
    GREATTHANEQUAL  reduce using rule 24 (constant -> cteS .)
    GREATTHAN       reduce using rule 24 (constant -> cteS .)
    LESSTHAN        reduce using rule 24 (constant -> cteS .)
    RGTPAREN        reduce using rule 24 (constant -> cteS .)
    SEMICOLON       reduce using rule 24 (constant -> cteS .)
    COMMA           reduce using rule 24 (constant -> cteS .)
    RGTBRACSQR      reduce using rule 24 (constant -> cteS .)


state 68

    (80) varsaux2 -> ID EQUAL varsaux constant .
    (81) varsaux2 -> ID EQUAL varsaux constant . COMMA varsaux2

    SEMICOLON       reduce using rule 80 (varsaux2 -> ID EQUAL varsaux constant .)
    COMMA           shift and go to state 96


state 69

    (29) cteS -> STRING .

    RGTPAREN        reduce using rule 29 (cteS -> STRING .)
    MULTIPLICATION  reduce using rule 29 (cteS -> STRING .)
    DIVISION        reduce using rule 29 (cteS -> STRING .)
    PLUS            reduce using rule 29 (cteS -> STRING .)
    MINUS           reduce using rule 29 (cteS -> STRING .)
    AND             reduce using rule 29 (cteS -> STRING .)
    DOUBEQUAL       reduce using rule 29 (cteS -> STRING .)
    NOT             reduce using rule 29 (cteS -> STRING .)
    OR              reduce using rule 29 (cteS -> STRING .)
    LESSTHANEQUAL   reduce using rule 29 (cteS -> STRING .)
    GREATTHANEQUAL  reduce using rule 29 (cteS -> STRING .)
    GREATTHAN       reduce using rule 29 (cteS -> STRING .)
    LESSTHAN        reduce using rule 29 (cteS -> STRING .)
    SEMICOLON       reduce using rule 29 (cteS -> STRING .)
    COMMA           reduce using rule 29 (cteS -> STRING .)
    RGTBRACSQR      reduce using rule 29 (cteS -> STRING .)


state 70

    (28) cteN -> INT .

    RGTPAREN        reduce using rule 28 (cteN -> INT .)
    COMMA           reduce using rule 28 (cteN -> INT .)
    SEMICOLON       reduce using rule 28 (cteN -> INT .)
    MULTIPLICATION  reduce using rule 28 (cteN -> INT .)
    DIVISION        reduce using rule 28 (cteN -> INT .)
    PLUS            reduce using rule 28 (cteN -> INT .)
    MINUS           reduce using rule 28 (cteN -> INT .)
    AND             reduce using rule 28 (cteN -> INT .)
    DOUBEQUAL       reduce using rule 28 (cteN -> INT .)
    NOT             reduce using rule 28 (cteN -> INT .)
    OR              reduce using rule 28 (cteN -> INT .)
    LESSTHANEQUAL   reduce using rule 28 (cteN -> INT .)
    GREATTHANEQUAL  reduce using rule 28 (cteN -> INT .)
    GREATTHAN       reduce using rule 28 (cteN -> INT .)
    LESSTHAN        reduce using rule 28 (cteN -> INT .)
    RGTBRACSQR      reduce using rule 28 (cteN -> INT .)


state 71

    (25) constant -> TRUE .

    MULTIPLICATION  reduce using rule 25 (constant -> TRUE .)
    DIVISION        reduce using rule 25 (constant -> TRUE .)
    PLUS            reduce using rule 25 (constant -> TRUE .)
    MINUS           reduce using rule 25 (constant -> TRUE .)
    AND             reduce using rule 25 (constant -> TRUE .)
    DOUBEQUAL       reduce using rule 25 (constant -> TRUE .)
    NOT             reduce using rule 25 (constant -> TRUE .)
    OR              reduce using rule 25 (constant -> TRUE .)
    LESSTHANEQUAL   reduce using rule 25 (constant -> TRUE .)
    GREATTHANEQUAL  reduce using rule 25 (constant -> TRUE .)
    GREATTHAN       reduce using rule 25 (constant -> TRUE .)
    LESSTHAN        reduce using rule 25 (constant -> TRUE .)
    RGTPAREN        reduce using rule 25 (constant -> TRUE .)
    SEMICOLON       reduce using rule 25 (constant -> TRUE .)
    COMMA           reduce using rule 25 (constant -> TRUE .)
    RGTBRACSQR      reduce using rule 25 (constant -> TRUE .)


state 72

    (27) cteN -> FLOAT .

    RGTPAREN        reduce using rule 27 (cteN -> FLOAT .)
    COMMA           reduce using rule 27 (cteN -> FLOAT .)
    SEMICOLON       reduce using rule 27 (cteN -> FLOAT .)
    MULTIPLICATION  reduce using rule 27 (cteN -> FLOAT .)
    DIVISION        reduce using rule 27 (cteN -> FLOAT .)
    PLUS            reduce using rule 27 (cteN -> FLOAT .)
    MINUS           reduce using rule 27 (cteN -> FLOAT .)
    AND             reduce using rule 27 (cteN -> FLOAT .)
    DOUBEQUAL       reduce using rule 27 (cteN -> FLOAT .)
    NOT             reduce using rule 27 (cteN -> FLOAT .)
    OR              reduce using rule 27 (cteN -> FLOAT .)
    LESSTHANEQUAL   reduce using rule 27 (cteN -> FLOAT .)
    GREATTHANEQUAL  reduce using rule 27 (cteN -> FLOAT .)
    GREATTHAN       reduce using rule 27 (cteN -> FLOAT .)
    LESSTHAN        reduce using rule 27 (cteN -> FLOAT .)
    RGTBRACSQR      reduce using rule 27 (cteN -> FLOAT .)


state 73

    (26) constant -> FALSE .

    MULTIPLICATION  reduce using rule 26 (constant -> FALSE .)
    DIVISION        reduce using rule 26 (constant -> FALSE .)
    PLUS            reduce using rule 26 (constant -> FALSE .)
    MINUS           reduce using rule 26 (constant -> FALSE .)
    AND             reduce using rule 26 (constant -> FALSE .)
    DOUBEQUAL       reduce using rule 26 (constant -> FALSE .)
    NOT             reduce using rule 26 (constant -> FALSE .)
    OR              reduce using rule 26 (constant -> FALSE .)
    LESSTHANEQUAL   reduce using rule 26 (constant -> FALSE .)
    GREATTHANEQUAL  reduce using rule 26 (constant -> FALSE .)
    GREATTHAN       reduce using rule 26 (constant -> FALSE .)
    LESSTHAN        reduce using rule 26 (constant -> FALSE .)
    RGTPAREN        reduce using rule 26 (constant -> FALSE .)
    SEMICOLON       reduce using rule 26 (constant -> FALSE .)
    COMMA           reduce using rule 26 (constant -> FALSE .)
    RGTBRACSQR      reduce using rule 26 (constant -> FALSE .)


state 74

    (22) constant -> array .

    MULTIPLICATION  reduce using rule 22 (constant -> array .)
    DIVISION        reduce using rule 22 (constant -> array .)
    PLUS            reduce using rule 22 (constant -> array .)
    MINUS           reduce using rule 22 (constant -> array .)
    AND             reduce using rule 22 (constant -> array .)
    DOUBEQUAL       reduce using rule 22 (constant -> array .)
    NOT             reduce using rule 22 (constant -> array .)
    OR              reduce using rule 22 (constant -> array .)
    LESSTHANEQUAL   reduce using rule 22 (constant -> array .)
    GREATTHANEQUAL  reduce using rule 22 (constant -> array .)
    GREATTHAN       reduce using rule 22 (constant -> array .)
    LESSTHAN        reduce using rule 22 (constant -> array .)
    RGTPAREN        reduce using rule 22 (constant -> array .)
    SEMICOLON       reduce using rule 22 (constant -> array .)
    COMMA           reduce using rule 22 (constant -> array .)
    RGTBRACSQR      reduce using rule 22 (constant -> array .)


state 75

    (23) constant -> cteN .

    MULTIPLICATION  reduce using rule 23 (constant -> cteN .)
    DIVISION        reduce using rule 23 (constant -> cteN .)
    PLUS            reduce using rule 23 (constant -> cteN .)
    MINUS           reduce using rule 23 (constant -> cteN .)
    AND             reduce using rule 23 (constant -> cteN .)
    DOUBEQUAL       reduce using rule 23 (constant -> cteN .)
    NOT             reduce using rule 23 (constant -> cteN .)
    OR              reduce using rule 23 (constant -> cteN .)
    LESSTHANEQUAL   reduce using rule 23 (constant -> cteN .)
    GREATTHANEQUAL  reduce using rule 23 (constant -> cteN .)
    GREATTHAN       reduce using rule 23 (constant -> cteN .)
    LESSTHAN        reduce using rule 23 (constant -> cteN .)
    RGTPAREN        reduce using rule 23 (constant -> cteN .)
    SEMICOLON       reduce using rule 23 (constant -> cteN .)
    COMMA           reduce using rule 23 (constant -> cteN .)
    RGTBRACSQR      reduce using rule 23 (constant -> cteN .)


state 76

    (21) constant -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR

    MULTIPLICATION  reduce using rule 21 (constant -> ID .)
    DIVISION        reduce using rule 21 (constant -> ID .)
    PLUS            reduce using rule 21 (constant -> ID .)
    MINUS           reduce using rule 21 (constant -> ID .)
    AND             reduce using rule 21 (constant -> ID .)
    DOUBEQUAL       reduce using rule 21 (constant -> ID .)
    NOT             reduce using rule 21 (constant -> ID .)
    OR              reduce using rule 21 (constant -> ID .)
    LESSTHANEQUAL   reduce using rule 21 (constant -> ID .)
    GREATTHANEQUAL  reduce using rule 21 (constant -> ID .)
    GREATTHAN       reduce using rule 21 (constant -> ID .)
    LESSTHAN        reduce using rule 21 (constant -> ID .)
    RGTPAREN        reduce using rule 21 (constant -> ID .)
    SEMICOLON       reduce using rule 21 (constant -> ID .)
    COMMA           reduce using rule 21 (constant -> ID .)
    RGTBRACSQR      reduce using rule 21 (constant -> ID .)
    LFTBRACSQR      shift and go to state 64


state 77

    (51) parameter -> type ID .
    (52) parameter -> type ID . COMMA parameter

    RGTPAREN        reduce using rule 51 (parameter -> type ID .)
    COMMA           shift and go to state 97


state 78

    (71) function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN . blockreturn
    (10) blockreturn -> . LFTBRAC blockreturnaux RGTBRAC
    (11) blockreturn -> . LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC

    LFTBRAC         shift and go to state 98

    blockreturn                    shift and go to state 99

state 79

    (84) read -> READ LFTPAREN ID . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 100


state 80

    (30) exp -> term .
    (31) exp -> term . expaux
    (32) expaux -> . PLUS exp expaux
    (33) expaux -> . MINUS exp expaux
    (34) expaux -> . empty
    (85) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for DOUBEQUAL resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for NOT resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for OR resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for LESSTHANEQUAL resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for GREATTHANEQUAL resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for GREATTHAN resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for RGTPAREN resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for COMMA resolved using rule 30 (exp -> term .)
  ! reduce/reduce conflict for RGTBRACSQR resolved using rule 30 (exp -> term .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 30 (exp -> term .)
    DOUBEQUAL       reduce using rule 30 (exp -> term .)
    NOT             reduce using rule 30 (exp -> term .)
    OR              reduce using rule 30 (exp -> term .)
    LESSTHANEQUAL   reduce using rule 30 (exp -> term .)
    GREATTHANEQUAL  reduce using rule 30 (exp -> term .)
    GREATTHAN       reduce using rule 30 (exp -> term .)
    LESSTHAN        reduce using rule 30 (exp -> term .)
    RGTPAREN        reduce using rule 30 (exp -> term .)
    SEMICOLON       reduce using rule 30 (exp -> term .)
    COMMA           reduce using rule 30 (exp -> term .)
    RGTBRACSQR      reduce using rule 30 (exp -> term .)
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103

  ! PLUS            [ reduce using rule 30 (exp -> term .) ]
  ! MINUS           [ reduce using rule 30 (exp -> term .) ]
  ! AND             [ reduce using rule 85 (empty -> .) ]
  ! DOUBEQUAL       [ reduce using rule 85 (empty -> .) ]
  ! NOT             [ reduce using rule 85 (empty -> .) ]
  ! OR              [ reduce using rule 85 (empty -> .) ]
  ! LESSTHANEQUAL   [ reduce using rule 85 (empty -> .) ]
  ! GREATTHANEQUAL  [ reduce using rule 85 (empty -> .) ]
  ! GREATTHAN       [ reduce using rule 85 (empty -> .) ]
  ! LESSTHAN        [ reduce using rule 85 (empty -> .) ]
  ! RGTPAREN        [ reduce using rule 85 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 85 (empty -> .) ]
  ! COMMA           [ reduce using rule 85 (empty -> .) ]
  ! RGTBRACSQR      [ reduce using rule 85 (empty -> .) ]
  ! PLUS            [ reduce using rule 85 (empty -> .) ]
  ! MINUS           [ reduce using rule 85 (empty -> .) ]

    expaux                         shift and go to state 101
    empty                          shift and go to state 104

state 81

    (36) factor -> LFTPAREN . expression RGTPAREN
    (39) expression -> . exp
    (40) expression -> . exp expressionaux exp
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 83
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85
    expression                     shift and go to state 105

state 82

    (37) factoraux -> PLUS .

    ID              reduce using rule 37 (factoraux -> PLUS .)
    TRUE            reduce using rule 37 (factoraux -> PLUS .)
    FALSE           reduce using rule 37 (factoraux -> PLUS .)
    FLOAT           reduce using rule 37 (factoraux -> PLUS .)
    INT             reduce using rule 37 (factoraux -> PLUS .)
    STRING          reduce using rule 37 (factoraux -> PLUS .)


state 83

    (39) expression -> exp .
    (40) expression -> exp . expressionaux exp
    (41) expressionaux -> . AND
    (42) expressionaux -> . DOUBEQUAL
    (43) expressionaux -> . NOT
    (44) expressionaux -> . OR
    (45) expressionaux -> . LESSTHANEQUAL
    (46) expressionaux -> . GREATTHANEQUAL
    (47) expressionaux -> . GREATTHAN
    (48) expressionaux -> . LESSTHAN

    RGTPAREN        reduce using rule 39 (expression -> exp .)
    SEMICOLON       reduce using rule 39 (expression -> exp .)
    AND             shift and go to state 106
    DOUBEQUAL       shift and go to state 113
    NOT             shift and go to state 112
    OR              shift and go to state 114
    LESSTHANEQUAL   shift and go to state 110
    GREATTHANEQUAL  shift and go to state 108
    GREATTHAN       shift and go to state 109
    LESSTHAN        shift and go to state 111

    expressionaux                  shift and go to state 107

state 84

    (54) term -> factor . termaux
    (55) termaux -> . MULTIPLICATION term termaux
    (56) termaux -> . DIVISION term termaux
    (57) termaux -> . empty
    (85) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 116
    DIVISION        shift and go to state 115
    PLUS            reduce using rule 85 (empty -> .)
    MINUS           reduce using rule 85 (empty -> .)
    AND             reduce using rule 85 (empty -> .)
    DOUBEQUAL       reduce using rule 85 (empty -> .)
    NOT             reduce using rule 85 (empty -> .)
    OR              reduce using rule 85 (empty -> .)
    LESSTHANEQUAL   reduce using rule 85 (empty -> .)
    GREATTHANEQUAL  reduce using rule 85 (empty -> .)
    GREATTHAN       reduce using rule 85 (empty -> .)
    LESSTHAN        reduce using rule 85 (empty -> .)
    RGTPAREN        reduce using rule 85 (empty -> .)
    SEMICOLON       reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)
    RGTBRACSQR      reduce using rule 85 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 85 (empty -> .) ]
  ! DIVISION        [ reduce using rule 85 (empty -> .) ]

    termaux                        shift and go to state 117
    empty                          shift and go to state 118

state 85

    (35) factor -> factoraux . constant
    (21) constant -> . ID
    (22) constant -> . array
    (23) constant -> . cteN
    (24) constant -> . cteS
    (25) constant -> . TRUE
    (26) constant -> . FALSE
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (27) cteN -> . FLOAT
    (28) cteN -> . INT
    (29) cteS -> . STRING

    ID              shift and go to state 76
    TRUE            shift and go to state 71
    FALSE           shift and go to state 73
    FLOAT           shift and go to state 72
    INT             shift and go to state 70
    STRING          shift and go to state 69

    cteS                           shift and go to state 67
    constant                       shift and go to state 119
    array                          shift and go to state 74
    cteN                           shift and go to state 75

state 86

    (49) loop -> WHILE LFTPAREN expression . RGTPAREN block

    RGTPAREN        shift and go to state 120


state 87

    (38) factoraux -> MINUS .

    ID              reduce using rule 38 (factoraux -> MINUS .)
    TRUE            reduce using rule 38 (factoraux -> MINUS .)
    FALSE           reduce using rule 38 (factoraux -> MINUS .)
    FLOAT           reduce using rule 38 (factoraux -> MINUS .)
    INT             reduce using rule 38 (factoraux -> MINUS .)
    STRING          reduce using rule 38 (factoraux -> MINUS .)


state 88

    (50) write -> PRINT LFTPAREN constant . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 121


state 89

    (7) assignment -> assignmentaux EQUAL call . SEMICOLON

    SEMICOLON       shift and go to state 122


state 90

    (6) assignment -> assignmentaux EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 123


state 91

    (82) call -> ID . LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> ID . LFTPAREN exp COMMA call RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 63


state 92

    (82) call -> ID LFTPAREN exp . RGTPAREN SEMICOLON
    (83) call -> ID LFTPAREN exp . COMMA call RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 124
    COMMA           shift and go to state 125


state 93

    (5) array -> ID LFTBRACSQR exp . RGTBRACSQR

    RGTBRACSQR      shift and go to state 126


state 94

    (19) conditionaux -> LFTPAREN expression . RGTPAREN block ELSEIF conditionaux
    (20) conditionaux -> LFTPAREN expression . RGTPAREN block

    RGTPAREN        shift and go to state 127


state 95

    (18) condition -> IF conditionaux ELSE . block
    (14) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 128

state 96

    (81) varsaux2 -> ID EQUAL varsaux constant COMMA . varsaux2
    (80) varsaux2 -> . ID EQUAL varsaux constant
    (81) varsaux2 -> . ID EQUAL varsaux constant COMMA varsaux2

    ID              shift and go to state 23

    varsaux2                       shift and go to state 129

state 97

    (52) parameter -> type ID COMMA . parameter
    (51) parameter -> . type ID
    (52) parameter -> . type ID COMMA parameter
    (53) parameter -> . empty
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING
    (85) empty -> .

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12
    RGTPAREN        reduce using rule 85 (empty -> .)

    parameter                      shift and go to state 130
    type                           shift and go to state 53
    empty                          shift and go to state 131

state 98

    (10) blockreturn -> LFTBRAC . blockreturnaux RGTBRAC
    (11) blockreturn -> LFTBRAC . blockreturnaux RETURN exp SEMICOLON RGTBRAC
    (12) blockreturnaux -> . statement blockreturnaux
    (13) blockreturnaux -> . empty
    (58) statement -> . assignment
    (59) statement -> . condition
    (60) statement -> . vars
    (61) statement -> . loop
    (62) statement -> . write
    (63) statement -> . read
    (64) statement -> . call
    (85) empty -> .
    (6) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (7) assignment -> . assignmentaux EQUAL call SEMICOLON
    (17) condition -> . IF conditionaux
    (18) condition -> . IF conditionaux ELSE block
    (76) vars -> . type varsaux2 SEMICOLON
    (49) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (50) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (82) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (8) assignmentaux -> . ID
    (9) assignmentaux -> . array
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 85 (empty -> .)
    RETURN          reduce using rule 85 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 34
    PRINT           shift and go to state 35
    READ            shift and go to state 33
    ID              shift and go to state 45
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    loop                           shift and go to state 48
    type                           shift and go to state 9
    vars                           shift and go to state 32
    read                           shift and go to state 38
    assignment                     shift and go to state 43
    write                          shift and go to state 37
    assignmentaux                  shift and go to state 44
    call                           shift and go to state 39
    condition                      shift and go to state 46
    statement                      shift and go to state 132
    blockreturnaux                 shift and go to state 133
    array                          shift and go to state 36
    empty                          shift and go to state 134

state 99

    (71) function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .

    FUNCTION        reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    INT             reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    FLOAT           reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    CHAR            reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    BOOL            reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    STRING          reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    PRIOMH          reduce using rule 71 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)


state 100

    (84) read -> READ LFTPAREN ID RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 101

    (31) exp -> term expaux .

    AND             reduce using rule 31 (exp -> term expaux .)
    DOUBEQUAL       reduce using rule 31 (exp -> term expaux .)
    NOT             reduce using rule 31 (exp -> term expaux .)
    OR              reduce using rule 31 (exp -> term expaux .)
    LESSTHANEQUAL   reduce using rule 31 (exp -> term expaux .)
    GREATTHANEQUAL  reduce using rule 31 (exp -> term expaux .)
    GREATTHAN       reduce using rule 31 (exp -> term expaux .)
    LESSTHAN        reduce using rule 31 (exp -> term expaux .)
    RGTPAREN        reduce using rule 31 (exp -> term expaux .)
    SEMICOLON       reduce using rule 31 (exp -> term expaux .)
    COMMA           reduce using rule 31 (exp -> term expaux .)
    RGTBRACSQR      reduce using rule 31 (exp -> term expaux .)
    PLUS            reduce using rule 31 (exp -> term expaux .)
    MINUS           reduce using rule 31 (exp -> term expaux .)


state 102

    (32) expaux -> PLUS . exp expaux
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 136
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 103

    (33) expaux -> MINUS . exp expaux
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 137
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 104

    (34) expaux -> empty .

    AND             reduce using rule 34 (expaux -> empty .)
    DOUBEQUAL       reduce using rule 34 (expaux -> empty .)
    NOT             reduce using rule 34 (expaux -> empty .)
    OR              reduce using rule 34 (expaux -> empty .)
    LESSTHANEQUAL   reduce using rule 34 (expaux -> empty .)
    GREATTHANEQUAL  reduce using rule 34 (expaux -> empty .)
    GREATTHAN       reduce using rule 34 (expaux -> empty .)
    LESSTHAN        reduce using rule 34 (expaux -> empty .)
    RGTPAREN        reduce using rule 34 (expaux -> empty .)
    SEMICOLON       reduce using rule 34 (expaux -> empty .)
    COMMA           reduce using rule 34 (expaux -> empty .)
    RGTBRACSQR      reduce using rule 34 (expaux -> empty .)
    PLUS            reduce using rule 34 (expaux -> empty .)
    MINUS           reduce using rule 34 (expaux -> empty .)


state 105

    (36) factor -> LFTPAREN expression . RGTPAREN

    RGTPAREN        shift and go to state 138


state 106

    (41) expressionaux -> AND .

    LFTPAREN        reduce using rule 41 (expressionaux -> AND .)
    PLUS            reduce using rule 41 (expressionaux -> AND .)
    MINUS           reduce using rule 41 (expressionaux -> AND .)


state 107

    (40) expression -> exp expressionaux . exp
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 139
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 108

    (46) expressionaux -> GREATTHANEQUAL .

    LFTPAREN        reduce using rule 46 (expressionaux -> GREATTHANEQUAL .)
    PLUS            reduce using rule 46 (expressionaux -> GREATTHANEQUAL .)
    MINUS           reduce using rule 46 (expressionaux -> GREATTHANEQUAL .)


state 109

    (47) expressionaux -> GREATTHAN .

    LFTPAREN        reduce using rule 47 (expressionaux -> GREATTHAN .)
    PLUS            reduce using rule 47 (expressionaux -> GREATTHAN .)
    MINUS           reduce using rule 47 (expressionaux -> GREATTHAN .)


state 110

    (45) expressionaux -> LESSTHANEQUAL .

    LFTPAREN        reduce using rule 45 (expressionaux -> LESSTHANEQUAL .)
    PLUS            reduce using rule 45 (expressionaux -> LESSTHANEQUAL .)
    MINUS           reduce using rule 45 (expressionaux -> LESSTHANEQUAL .)


state 111

    (48) expressionaux -> LESSTHAN .

    LFTPAREN        reduce using rule 48 (expressionaux -> LESSTHAN .)
    PLUS            reduce using rule 48 (expressionaux -> LESSTHAN .)
    MINUS           reduce using rule 48 (expressionaux -> LESSTHAN .)


state 112

    (43) expressionaux -> NOT .

    LFTPAREN        reduce using rule 43 (expressionaux -> NOT .)
    PLUS            reduce using rule 43 (expressionaux -> NOT .)
    MINUS           reduce using rule 43 (expressionaux -> NOT .)


state 113

    (42) expressionaux -> DOUBEQUAL .

    LFTPAREN        reduce using rule 42 (expressionaux -> DOUBEQUAL .)
    PLUS            reduce using rule 42 (expressionaux -> DOUBEQUAL .)
    MINUS           reduce using rule 42 (expressionaux -> DOUBEQUAL .)


state 114

    (44) expressionaux -> OR .

    LFTPAREN        reduce using rule 44 (expressionaux -> OR .)
    PLUS            reduce using rule 44 (expressionaux -> OR .)
    MINUS           reduce using rule 44 (expressionaux -> OR .)


state 115

    (56) termaux -> DIVISION . term termaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 140
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 116

    (55) termaux -> MULTIPLICATION . term termaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 141
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 117

    (54) term -> factor termaux .

    PLUS            reduce using rule 54 (term -> factor termaux .)
    MINUS           reduce using rule 54 (term -> factor termaux .)
    RGTPAREN        reduce using rule 54 (term -> factor termaux .)
    SEMICOLON       reduce using rule 54 (term -> factor termaux .)
    AND             reduce using rule 54 (term -> factor termaux .)
    DOUBEQUAL       reduce using rule 54 (term -> factor termaux .)
    NOT             reduce using rule 54 (term -> factor termaux .)
    OR              reduce using rule 54 (term -> factor termaux .)
    LESSTHANEQUAL   reduce using rule 54 (term -> factor termaux .)
    GREATTHANEQUAL  reduce using rule 54 (term -> factor termaux .)
    GREATTHAN       reduce using rule 54 (term -> factor termaux .)
    LESSTHAN        reduce using rule 54 (term -> factor termaux .)
    COMMA           reduce using rule 54 (term -> factor termaux .)
    RGTBRACSQR      reduce using rule 54 (term -> factor termaux .)
    MULTIPLICATION  reduce using rule 54 (term -> factor termaux .)
    DIVISION        reduce using rule 54 (term -> factor termaux .)


state 118

    (57) termaux -> empty .

    PLUS            reduce using rule 57 (termaux -> empty .)
    MINUS           reduce using rule 57 (termaux -> empty .)
    AND             reduce using rule 57 (termaux -> empty .)
    DOUBEQUAL       reduce using rule 57 (termaux -> empty .)
    NOT             reduce using rule 57 (termaux -> empty .)
    OR              reduce using rule 57 (termaux -> empty .)
    LESSTHANEQUAL   reduce using rule 57 (termaux -> empty .)
    GREATTHANEQUAL  reduce using rule 57 (termaux -> empty .)
    GREATTHAN       reduce using rule 57 (termaux -> empty .)
    LESSTHAN        reduce using rule 57 (termaux -> empty .)
    RGTPAREN        reduce using rule 57 (termaux -> empty .)
    SEMICOLON       reduce using rule 57 (termaux -> empty .)
    COMMA           reduce using rule 57 (termaux -> empty .)
    RGTBRACSQR      reduce using rule 57 (termaux -> empty .)
    MULTIPLICATION  reduce using rule 57 (termaux -> empty .)
    DIVISION        reduce using rule 57 (termaux -> empty .)


state 119

    (35) factor -> factoraux constant .

    MULTIPLICATION  reduce using rule 35 (factor -> factoraux constant .)
    DIVISION        reduce using rule 35 (factor -> factoraux constant .)
    PLUS            reduce using rule 35 (factor -> factoraux constant .)
    MINUS           reduce using rule 35 (factor -> factoraux constant .)
    AND             reduce using rule 35 (factor -> factoraux constant .)
    DOUBEQUAL       reduce using rule 35 (factor -> factoraux constant .)
    NOT             reduce using rule 35 (factor -> factoraux constant .)
    OR              reduce using rule 35 (factor -> factoraux constant .)
    LESSTHANEQUAL   reduce using rule 35 (factor -> factoraux constant .)
    GREATTHANEQUAL  reduce using rule 35 (factor -> factoraux constant .)
    GREATTHAN       reduce using rule 35 (factor -> factoraux constant .)
    LESSTHAN        reduce using rule 35 (factor -> factoraux constant .)
    RGTPAREN        reduce using rule 35 (factor -> factoraux constant .)
    SEMICOLON       reduce using rule 35 (factor -> factoraux constant .)
    COMMA           reduce using rule 35 (factor -> factoraux constant .)
    RGTBRACSQR      reduce using rule 35 (factor -> factoraux constant .)


state 120

    (49) loop -> WHILE LFTPAREN expression RGTPAREN . block
    (14) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 142

state 121

    (50) write -> PRINT LFTPAREN constant RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 143


state 122

    (7) assignment -> assignmentaux EQUAL call SEMICOLON .

    IF              reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    WHILE           reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    PRINT           reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    READ            reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    ID              reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    INT             reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    FLOAT           reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    CHAR            reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    BOOL            reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    STRING          reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    RGTBRAC         reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    RETURN          reduce using rule 7 (assignment -> assignmentaux EQUAL call SEMICOLON .)


state 123

    (6) assignment -> assignmentaux EQUAL expression SEMICOLON .

    IF              reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    READ            reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    ID              reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    INT             reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    STRING          reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    RGTBRAC         reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 6 (assignment -> assignmentaux EQUAL expression SEMICOLON .)


state 124

    (82) call -> ID LFTPAREN exp RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 144


state 125

    (83) call -> ID LFTPAREN exp COMMA . call RGTPAREN SEMICOLON
    (82) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON

    ID              shift and go to state 91

    call                           shift and go to state 145

state 126

    (5) array -> ID LFTBRACSQR exp RGTBRACSQR .

    EQUAL           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    MULTIPLICATION  reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    DIVISION        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    PLUS            reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    MINUS           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    AND             reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    DOUBEQUAL       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    NOT             reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    OR              reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    LESSTHANEQUAL   reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    GREATTHANEQUAL  reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    GREATTHAN       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    LESSTHAN        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    RGTPAREN        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    SEMICOLON       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    COMMA           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    RGTBRACSQR      reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)


state 127

    (19) conditionaux -> LFTPAREN expression RGTPAREN . block ELSEIF conditionaux
    (20) conditionaux -> LFTPAREN expression RGTPAREN . block
    (14) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 146

state 128

    (18) condition -> IF conditionaux ELSE block .

    IF              reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    WHILE           reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    PRINT           reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    READ            reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    ID              reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    INT             reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    FLOAT           reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    CHAR            reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    BOOL            reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    STRING          reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    RGTBRAC         reduce using rule 18 (condition -> IF conditionaux ELSE block .)
    RETURN          reduce using rule 18 (condition -> IF conditionaux ELSE block .)


state 129

    (81) varsaux2 -> ID EQUAL varsaux constant COMMA varsaux2 .

    SEMICOLON       reduce using rule 81 (varsaux2 -> ID EQUAL varsaux constant COMMA varsaux2 .)


state 130

    (52) parameter -> type ID COMMA parameter .

    RGTPAREN        reduce using rule 52 (parameter -> type ID COMMA parameter .)


state 131

    (53) parameter -> empty .

    RGTPAREN        reduce using rule 53 (parameter -> empty .)


state 132

    (12) blockreturnaux -> statement . blockreturnaux
    (12) blockreturnaux -> . statement blockreturnaux
    (13) blockreturnaux -> . empty
    (58) statement -> . assignment
    (59) statement -> . condition
    (60) statement -> . vars
    (61) statement -> . loop
    (62) statement -> . write
    (63) statement -> . read
    (64) statement -> . call
    (85) empty -> .
    (6) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (7) assignment -> . assignmentaux EQUAL call SEMICOLON
    (17) condition -> . IF conditionaux
    (18) condition -> . IF conditionaux ELSE block
    (76) vars -> . type varsaux2 SEMICOLON
    (49) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (50) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (84) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (82) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (83) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (8) assignmentaux -> . ID
    (9) assignmentaux -> . array
    (65) type -> . INT
    (66) type -> . FLOAT
    (67) type -> . CHAR
    (68) type -> . BOOL
    (69) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 85 (empty -> .)
    RETURN          reduce using rule 85 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 34
    PRINT           shift and go to state 35
    READ            shift and go to state 33
    ID              shift and go to state 45
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    loop                           shift and go to state 48
    type                           shift and go to state 9
    vars                           shift and go to state 32
    read                           shift and go to state 38
    assignment                     shift and go to state 43
    write                          shift and go to state 37
    assignmentaux                  shift and go to state 44
    call                           shift and go to state 39
    empty                          shift and go to state 134
    statement                      shift and go to state 132
    blockreturnaux                 shift and go to state 147
    array                          shift and go to state 36
    condition                      shift and go to state 46

state 133

    (10) blockreturn -> LFTBRAC blockreturnaux . RGTBRAC
    (11) blockreturn -> LFTBRAC blockreturnaux . RETURN exp SEMICOLON RGTBRAC

    RGTBRAC         shift and go to state 149
    RETURN          shift and go to state 148


state 134

    (13) blockreturnaux -> empty .

    RGTBRAC         reduce using rule 13 (blockreturnaux -> empty .)
    RETURN          reduce using rule 13 (blockreturnaux -> empty .)


state 135

    (84) read -> READ LFTPAREN ID RGTPAREN SEMICOLON .

    IF              reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    READ            reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    ID              reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    INT             reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    STRING          reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 84 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)


state 136

    (32) expaux -> PLUS exp . expaux
    (32) expaux -> . PLUS exp expaux
    (33) expaux -> . MINUS exp expaux
    (34) expaux -> . empty
    (85) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             reduce using rule 85 (empty -> .)
    DOUBEQUAL       reduce using rule 85 (empty -> .)
    NOT             reduce using rule 85 (empty -> .)
    OR              reduce using rule 85 (empty -> .)
    LESSTHANEQUAL   reduce using rule 85 (empty -> .)
    GREATTHANEQUAL  reduce using rule 85 (empty -> .)
    GREATTHAN       reduce using rule 85 (empty -> .)
    LESSTHAN        reduce using rule 85 (empty -> .)
    RGTPAREN        reduce using rule 85 (empty -> .)
    SEMICOLON       reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)
    RGTBRACSQR      reduce using rule 85 (empty -> .)

  ! PLUS            [ reduce using rule 85 (empty -> .) ]
  ! MINUS           [ reduce using rule 85 (empty -> .) ]

    expaux                         shift and go to state 150
    empty                          shift and go to state 104

state 137

    (33) expaux -> MINUS exp . expaux
    (32) expaux -> . PLUS exp expaux
    (33) expaux -> . MINUS exp expaux
    (34) expaux -> . empty
    (85) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 102
    MINUS           shift and go to state 103
    AND             reduce using rule 85 (empty -> .)
    DOUBEQUAL       reduce using rule 85 (empty -> .)
    NOT             reduce using rule 85 (empty -> .)
    OR              reduce using rule 85 (empty -> .)
    LESSTHANEQUAL   reduce using rule 85 (empty -> .)
    GREATTHANEQUAL  reduce using rule 85 (empty -> .)
    GREATTHAN       reduce using rule 85 (empty -> .)
    LESSTHAN        reduce using rule 85 (empty -> .)
    RGTPAREN        reduce using rule 85 (empty -> .)
    SEMICOLON       reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)
    RGTBRACSQR      reduce using rule 85 (empty -> .)

  ! PLUS            [ reduce using rule 85 (empty -> .) ]
  ! MINUS           [ reduce using rule 85 (empty -> .) ]

    expaux                         shift and go to state 151
    empty                          shift and go to state 104

state 138

    (36) factor -> LFTPAREN expression RGTPAREN .

    MULTIPLICATION  reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    DIVISION        reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    PLUS            reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    MINUS           reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    AND             reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    DOUBEQUAL       reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    NOT             reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    OR              reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    LESSTHANEQUAL   reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    GREATTHANEQUAL  reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    GREATTHAN       reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    LESSTHAN        reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    RGTPAREN        reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    SEMICOLON       reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    COMMA           reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)
    RGTBRACSQR      reduce using rule 36 (factor -> LFTPAREN expression RGTPAREN .)


state 139

    (40) expression -> exp expressionaux exp .

    RGTPAREN        reduce using rule 40 (expression -> exp expressionaux exp .)
    SEMICOLON       reduce using rule 40 (expression -> exp expressionaux exp .)


state 140

    (56) termaux -> DIVISION term . termaux
    (55) termaux -> . MULTIPLICATION term termaux
    (56) termaux -> . DIVISION term termaux
    (57) termaux -> . empty
    (85) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 116
    DIVISION        shift and go to state 115
    PLUS            reduce using rule 85 (empty -> .)
    MINUS           reduce using rule 85 (empty -> .)
    AND             reduce using rule 85 (empty -> .)
    DOUBEQUAL       reduce using rule 85 (empty -> .)
    NOT             reduce using rule 85 (empty -> .)
    OR              reduce using rule 85 (empty -> .)
    LESSTHANEQUAL   reduce using rule 85 (empty -> .)
    GREATTHANEQUAL  reduce using rule 85 (empty -> .)
    GREATTHAN       reduce using rule 85 (empty -> .)
    LESSTHAN        reduce using rule 85 (empty -> .)
    RGTPAREN        reduce using rule 85 (empty -> .)
    SEMICOLON       reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)
    RGTBRACSQR      reduce using rule 85 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 85 (empty -> .) ]
  ! DIVISION        [ reduce using rule 85 (empty -> .) ]

    termaux                        shift and go to state 152
    empty                          shift and go to state 118

state 141

    (55) termaux -> MULTIPLICATION term . termaux
    (55) termaux -> . MULTIPLICATION term termaux
    (56) termaux -> . DIVISION term termaux
    (57) termaux -> . empty
    (85) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 116
    DIVISION        shift and go to state 115
    PLUS            reduce using rule 85 (empty -> .)
    MINUS           reduce using rule 85 (empty -> .)
    AND             reduce using rule 85 (empty -> .)
    DOUBEQUAL       reduce using rule 85 (empty -> .)
    NOT             reduce using rule 85 (empty -> .)
    OR              reduce using rule 85 (empty -> .)
    LESSTHANEQUAL   reduce using rule 85 (empty -> .)
    GREATTHANEQUAL  reduce using rule 85 (empty -> .)
    GREATTHAN       reduce using rule 85 (empty -> .)
    LESSTHAN        reduce using rule 85 (empty -> .)
    RGTPAREN        reduce using rule 85 (empty -> .)
    SEMICOLON       reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)
    RGTBRACSQR      reduce using rule 85 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 85 (empty -> .) ]
  ! DIVISION        [ reduce using rule 85 (empty -> .) ]

    termaux                        shift and go to state 153
    empty                          shift and go to state 118

state 142

    (49) loop -> WHILE LFTPAREN expression RGTPAREN block .

    IF              reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    WHILE           reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    PRINT           reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    READ            reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    ID              reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    INT             reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    FLOAT           reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    CHAR            reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    BOOL            reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    STRING          reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    RGTBRAC         reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    RETURN          reduce using rule 49 (loop -> WHILE LFTPAREN expression RGTPAREN block .)


state 143

    (50) write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .

    IF              reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    READ            reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    ID              reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    INT             reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    STRING          reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 50 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)


state 144

    (82) call -> ID LFTPAREN exp RGTPAREN SEMICOLON .

    IF              reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    READ            reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    ID              reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    INT             reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    STRING          reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    RGTPAREN        reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 82 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)


state 145

    (83) call -> ID LFTPAREN exp COMMA call . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 154


state 146

    (19) conditionaux -> LFTPAREN expression RGTPAREN block . ELSEIF conditionaux
    (20) conditionaux -> LFTPAREN expression RGTPAREN block .

    ELSEIF          shift and go to state 155
    ELSE            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    IF              reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    WHILE           reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    PRINT           reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    READ            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    ID              reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    INT             reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    FLOAT           reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    CHAR            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    BOOL            reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    STRING          reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    RGTBRAC         reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    RETURN          reduce using rule 20 (conditionaux -> LFTPAREN expression RGTPAREN block .)


state 147

    (12) blockreturnaux -> statement blockreturnaux .

    RGTBRAC         reduce using rule 12 (blockreturnaux -> statement blockreturnaux .)
    RETURN          reduce using rule 12 (blockreturnaux -> statement blockreturnaux .)


state 148

    (11) blockreturn -> LFTBRAC blockreturnaux RETURN . exp SEMICOLON RGTBRAC
    (30) exp -> . term
    (31) exp -> . term expaux
    (54) term -> . factor termaux
    (35) factor -> . factoraux constant
    (36) factor -> . LFTPAREN expression RGTPAREN
    (37) factoraux -> . PLUS
    (38) factoraux -> . MINUS

    LFTPAREN        shift and go to state 81
    PLUS            shift and go to state 82
    MINUS           shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 156
    factor                         shift and go to state 84
    factoraux                      shift and go to state 85

state 149

    (10) blockreturn -> LFTBRAC blockreturnaux RGTBRAC .

    FUNCTION        reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    INT             reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    FLOAT           reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    CHAR            reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    BOOL            reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    STRING          reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    PRIOMH          reduce using rule 10 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)


state 150

    (32) expaux -> PLUS exp expaux .

    AND             reduce using rule 32 (expaux -> PLUS exp expaux .)
    DOUBEQUAL       reduce using rule 32 (expaux -> PLUS exp expaux .)
    NOT             reduce using rule 32 (expaux -> PLUS exp expaux .)
    OR              reduce using rule 32 (expaux -> PLUS exp expaux .)
    LESSTHANEQUAL   reduce using rule 32 (expaux -> PLUS exp expaux .)
    GREATTHANEQUAL  reduce using rule 32 (expaux -> PLUS exp expaux .)
    GREATTHAN       reduce using rule 32 (expaux -> PLUS exp expaux .)
    LESSTHAN        reduce using rule 32 (expaux -> PLUS exp expaux .)
    RGTPAREN        reduce using rule 32 (expaux -> PLUS exp expaux .)
    SEMICOLON       reduce using rule 32 (expaux -> PLUS exp expaux .)
    COMMA           reduce using rule 32 (expaux -> PLUS exp expaux .)
    RGTBRACSQR      reduce using rule 32 (expaux -> PLUS exp expaux .)
    PLUS            reduce using rule 32 (expaux -> PLUS exp expaux .)
    MINUS           reduce using rule 32 (expaux -> PLUS exp expaux .)


state 151

    (33) expaux -> MINUS exp expaux .

    AND             reduce using rule 33 (expaux -> MINUS exp expaux .)
    DOUBEQUAL       reduce using rule 33 (expaux -> MINUS exp expaux .)
    NOT             reduce using rule 33 (expaux -> MINUS exp expaux .)
    OR              reduce using rule 33 (expaux -> MINUS exp expaux .)
    LESSTHANEQUAL   reduce using rule 33 (expaux -> MINUS exp expaux .)
    GREATTHANEQUAL  reduce using rule 33 (expaux -> MINUS exp expaux .)
    GREATTHAN       reduce using rule 33 (expaux -> MINUS exp expaux .)
    LESSTHAN        reduce using rule 33 (expaux -> MINUS exp expaux .)
    RGTPAREN        reduce using rule 33 (expaux -> MINUS exp expaux .)
    SEMICOLON       reduce using rule 33 (expaux -> MINUS exp expaux .)
    COMMA           reduce using rule 33 (expaux -> MINUS exp expaux .)
    RGTBRACSQR      reduce using rule 33 (expaux -> MINUS exp expaux .)
    PLUS            reduce using rule 33 (expaux -> MINUS exp expaux .)
    MINUS           reduce using rule 33 (expaux -> MINUS exp expaux .)


state 152

    (56) termaux -> DIVISION term termaux .

    PLUS            reduce using rule 56 (termaux -> DIVISION term termaux .)
    MINUS           reduce using rule 56 (termaux -> DIVISION term termaux .)
    AND             reduce using rule 56 (termaux -> DIVISION term termaux .)
    DOUBEQUAL       reduce using rule 56 (termaux -> DIVISION term termaux .)
    NOT             reduce using rule 56 (termaux -> DIVISION term termaux .)
    OR              reduce using rule 56 (termaux -> DIVISION term termaux .)
    LESSTHANEQUAL   reduce using rule 56 (termaux -> DIVISION term termaux .)
    GREATTHANEQUAL  reduce using rule 56 (termaux -> DIVISION term termaux .)
    GREATTHAN       reduce using rule 56 (termaux -> DIVISION term termaux .)
    LESSTHAN        reduce using rule 56 (termaux -> DIVISION term termaux .)
    RGTPAREN        reduce using rule 56 (termaux -> DIVISION term termaux .)
    SEMICOLON       reduce using rule 56 (termaux -> DIVISION term termaux .)
    COMMA           reduce using rule 56 (termaux -> DIVISION term termaux .)
    RGTBRACSQR      reduce using rule 56 (termaux -> DIVISION term termaux .)
    MULTIPLICATION  reduce using rule 56 (termaux -> DIVISION term termaux .)
    DIVISION        reduce using rule 56 (termaux -> DIVISION term termaux .)


state 153

    (55) termaux -> MULTIPLICATION term termaux .

    PLUS            reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    MINUS           reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    AND             reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    DOUBEQUAL       reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    NOT             reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    OR              reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    LESSTHANEQUAL   reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    GREATTHANEQUAL  reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    GREATTHAN       reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    LESSTHAN        reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    RGTPAREN        reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    SEMICOLON       reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    COMMA           reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    RGTBRACSQR      reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    MULTIPLICATION  reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)
    DIVISION        reduce using rule 55 (termaux -> MULTIPLICATION term termaux .)


state 154

    (83) call -> ID LFTPAREN exp COMMA call RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 157


state 155

    (19) conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF . conditionaux
    (19) conditionaux -> . LFTPAREN expression RGTPAREN block ELSEIF conditionaux
    (20) conditionaux -> . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 65

    conditionaux                   shift and go to state 158

state 156

    (11) blockreturn -> LFTBRAC blockreturnaux RETURN exp . SEMICOLON RGTBRAC

    SEMICOLON       shift and go to state 159


state 157

    (83) call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .

    IF              reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    READ            reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    ID              reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    INT             reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    STRING          reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    RGTPAREN        reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 83 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)


state 158

    (19) conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .

    ELSE            reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    IF              reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    WHILE           reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    PRINT           reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    READ            reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    ID              reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    INT             reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    FLOAT           reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    CHAR            reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    BOOL            reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    STRING          reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    RGTBRAC         reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    RETURN          reduce using rule 19 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)


state 159

    (11) blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON . RGTBRAC

    RGTBRAC         shift and go to state 160


state 160

    (11) blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .

    FUNCTION        reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    INT             reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    FLOAT           reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    CHAR            reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    BOOL            reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    STRING          reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    PRIOMH          reduce using rule 11 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 84 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 136 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 140 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 141 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 141 resolved as shift
WARNING: reduce/reduce conflict in state 56 resolved using rule (parameter -> empty)
WARNING: rejected rule (functionaux2 -> empty) in state 56
WARNING: reduce/reduce conflict in state 80 resolved using rule (exp -> term)
WARNING: rejected rule (empty -> <empty>) in state 80
WARNING: Rule (functionaux2 -> empty) is never reduced
