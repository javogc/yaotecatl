Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    WRITE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC
Rule 2     auxprogram -> vars auxprogram
Rule 3     auxprogram -> function auxprogram
Rule 4     auxprogram -> empty
Rule 5     array -> ID LFTBRACSQR exp RGTBRACSQR
Rule 6     arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR
Rule 7     arrayvaluesaux -> cteN arrayvaluesaux2
Rule 8     arrayvaluesaux -> cteS arrayvaluesaux2
Rule 9     arrayvaluesaux2 -> COMMA arrayvaluesaux
Rule 10    arrayvaluesaux2 -> empty
Rule 11    assignment -> assignmentaux EQUAL expression SEMICOLON
Rule 12    assignment -> assignmentaux EQUAL call SEMICOLON
Rule 13    assignmentaux -> ID
Rule 14    assignmentaux -> array
Rule 15    blockreturn -> LFTBRAC blockreturnaux RGTBRAC
Rule 16    blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC
Rule 17    blockreturnaux -> statement blockreturnaux
Rule 18    blockreturnaux -> empty
Rule 19    block -> LFTBRAC blockaux RGTBRAC
Rule 20    blockaux -> statement blockaux
Rule 21    blockaux -> empty
Rule 22    condition -> IF conditionaux
Rule 23    condition -> IF conditionaux ELSE block
Rule 24    conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux
Rule 25    conditionaux -> LFTPAREN expression RGTPAREN block
Rule 26    constant -> ID
Rule 27    constant -> array
Rule 28    constant -> cteN
Rule 29    constant -> cteS
Rule 30    constant -> TRUE
Rule 31    constant -> FALSE
Rule 32    cteN -> FLOAT
Rule 33    cteN -> INT
Rule 34    cteS -> STRING
Rule 35    exp -> term
Rule 36    exp -> term expaux
Rule 37    expaux -> PLUS exp expaux
Rule 38    expaux -> MINUS exp expaux
Rule 39    expaux -> empty
Rule 40    factor -> factoraux constant
Rule 41    factor -> LFTPAREN expression RGTPAREN
Rule 42    factoraux -> PLUS
Rule 43    factoraux -> MINUS
Rule 44    factoraux -> empty
Rule 45    expression -> exp
Rule 46    expression -> exp expressionaux exp
Rule 47    expressionaux -> AND
Rule 48    expressionaux -> DOUBEQUAL
Rule 49    expressionaux -> NOT
Rule 50    expressionaux -> OR
Rule 51    expressionaux -> LESSTHANEQUAL
Rule 52    expressionaux -> GREATTHANEQUAL
Rule 53    expressionaux -> GREATTHAN
Rule 54    expressionaux -> LESSTHAN
Rule 55    loop -> WHILE LFTPAREN expression RGTPAREN block
Rule 56    write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON
Rule 57    parameter -> type ID
Rule 58    parameter -> type ID COMMA parameter
Rule 59    parameter -> empty
Rule 60    term -> factor termaux
Rule 61    termaux -> MULTIPLICATION term termaux
Rule 62    termaux -> DIVISION term termaux
Rule 63    termaux -> empty
Rule 64    statement -> assignment
Rule 65    statement -> condition
Rule 66    statement -> vars
Rule 67    statement -> loop
Rule 68    statement -> write
Rule 69    statement -> read
Rule 70    statement -> call
Rule 71    type -> INT
Rule 72    type -> FLOAT
Rule 73    type -> CHAR
Rule 74    type -> BOOL
Rule 75    type -> STRING
Rule 76    main -> PRIOMH block
Rule 77    function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
Rule 78    functionaux -> VOID
Rule 79    functionaux -> type
Rule 80    functionaux2 -> parameter
Rule 81    functionaux2 -> empty
Rule 82    vars -> type varsaux2 SEMICOLON
Rule 83    varsaux -> PLUS
Rule 84    varsaux -> MINUS
Rule 85    varsaux -> empty
Rule 86    varsaux2 -> ID EQUAL varsaux constant
Rule 87    varsaux2 -> ID EQUAL varsaux constant COMMA varsaux2
Rule 88    varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues
Rule 89    varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2
Rule 90    call -> ID LFTPAREN exp RGTPAREN SEMICOLON
Rule 91    call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
Rule 92    read -> READ LFTPAREN ID RGTPAREN SEMICOLON
Rule 93    empty -> <empty>

Terminals, with rules where they appear

AND                  : 47
ARRAY                : 
BOOL                 : 74
CHAR                 : 73
COMMA                : 9 58 87 89 91
DIVISION             : 62
DOUBEQUAL            : 48
ELSE                 : 23
ELSEIF               : 24
EQUAL                : 11 12 86 87 88 89
FALSE                : 31
FLOAT                : 32 72
FUNCTION             : 77
GREATTHAN            : 53
GREATTHANEQUAL       : 52
ID                   : 1 5 13 26 57 58 77 86 87 88 89 90 91 92
IF                   : 22 23
INT                  : 33 71 88 89
LESSTHAN             : 54
LESSTHANEQUAL        : 51
LFTBRAC              : 1 15 16 19
LFTBRACSQR           : 5 6 88 89
LFTPAREN             : 24 25 41 55 56 77 90 91 92
MINUS                : 38 43 84
MULTIPLICATION       : 61
NOT                  : 49
OR                   : 50
PLUS                 : 37 42 83
PRINT                : 56
PRIOMH               : 76
PROGRAM              : 1
READ                 : 92
RETURN               : 16
RGTBRAC              : 1 15 16 19
RGTBRACSQR           : 5 6 88 89
RGTPAREN             : 24 25 41 55 56 77 90 91 92
SEMICOLON            : 11 12 16 56 82 90 91 92
STRING               : 34 75
TRUE                 : 30
VOID                 : 78
WHILE                : 55
WRITE                : 
error                : 

Nonterminals, with rules where they appear

array                : 14 27
arrayvalues          : 88 89
arrayvaluesaux       : 6 9
arrayvaluesaux2      : 7 8
assignment           : 64
assignmentaux        : 11 12
auxprogram           : 1 2 3
block                : 23 24 25 55 76
blockaux             : 19 20
blockreturn          : 77
blockreturnaux       : 15 16 17
call                 : 12 70 91
condition            : 65
conditionaux         : 22 23 24
constant             : 40 56 86 87
cteN                 : 7 28
cteS                 : 8 29
empty                : 4 10 18 21 39 44 59 63 81 85
exp                  : 5 16 37 38 45 46 46 90 91
expaux               : 36 37 38
expression           : 11 24 25 41 55
expressionaux        : 46
factor               : 60
factoraux            : 40
function             : 3
functionaux          : 77
functionaux2         : 77
loop                 : 67
main                 : 1
parameter            : 58 80
program              : 0
read                 : 69
statement            : 17 20
term                 : 35 36 61 62
termaux              : 60 61 62
type                 : 57 58 79 82
vars                 : 2 66
varsaux              : 86 87
varsaux2             : 82 87 89
write                : 68

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID LFTBRAC auxprogram main RGTBRAC

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID LFTBRAC auxprogram main RGTBRAC

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . LFTBRAC auxprogram main RGTBRAC

    LFTBRAC         shift and go to state 4


state 4

    (1) program -> PROGRAM ID LFTBRAC . auxprogram main RGTBRAC
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (82) vars -> . type varsaux2 SEMICOLON
    (77) function -> . FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (93) empty -> .
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 93 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    function                       shift and go to state 11
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 8
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 5

    (77) function -> FUNCTION . functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (78) functionaux -> . VOID
    (79) functionaux -> . type
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING

    VOID            shift and go to state 16
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    functionaux                    shift and go to state 17
    type                           shift and go to state 18

state 6

    (2) auxprogram -> vars . auxprogram
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (82) vars -> . type varsaux2 SEMICOLON
    (77) function -> . FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (93) empty -> .
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 93 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    function                       shift and go to state 11
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 19
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 7

    (73) type -> CHAR .

    ID              reduce using rule 73 (type -> CHAR .)


state 8

    (1) program -> PROGRAM ID LFTBRAC auxprogram . main RGTBRAC
    (76) main -> . PRIOMH block

    PRIOMH          shift and go to state 20

    main                           shift and go to state 21

state 9

    (82) vars -> type . varsaux2 SEMICOLON
    (86) varsaux2 -> . ID EQUAL varsaux constant
    (87) varsaux2 -> . ID EQUAL varsaux constant COMMA varsaux2
    (88) varsaux2 -> . ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues
    (89) varsaux2 -> . ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2

    ID              shift and go to state 23

    varsaux2                       shift and go to state 22

state 10

    (4) auxprogram -> empty .

    PRIOMH          reduce using rule 4 (auxprogram -> empty .)


state 11

    (3) auxprogram -> function . auxprogram
    (2) auxprogram -> . vars auxprogram
    (3) auxprogram -> . function auxprogram
    (4) auxprogram -> . empty
    (82) vars -> . type varsaux2 SEMICOLON
    (77) function -> . FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn
    (93) empty -> .
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING

    FUNCTION        shift and go to state 5
    PRIOMH          reduce using rule 93 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    function                       shift and go to state 11
    vars                           shift and go to state 6
    auxprogram                     shift and go to state 24
    type                           shift and go to state 9
    empty                          shift and go to state 10

state 12

    (75) type -> STRING .

    ID              reduce using rule 75 (type -> STRING .)


state 13

    (71) type -> INT .

    ID              reduce using rule 71 (type -> INT .)


state 14

    (72) type -> FLOAT .

    ID              reduce using rule 72 (type -> FLOAT .)


state 15

    (74) type -> BOOL .

    ID              reduce using rule 74 (type -> BOOL .)


state 16

    (78) functionaux -> VOID .

    ID              reduce using rule 78 (functionaux -> VOID .)


state 17

    (77) function -> FUNCTION functionaux . ID LFTPAREN functionaux2 RGTPAREN blockreturn

    ID              shift and go to state 25


state 18

    (79) functionaux -> type .

    ID              reduce using rule 79 (functionaux -> type .)


state 19

    (2) auxprogram -> vars auxprogram .

    PRIOMH          reduce using rule 2 (auxprogram -> vars auxprogram .)


state 20

    (76) main -> PRIOMH . block
    (19) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 27

state 21

    (1) program -> PROGRAM ID LFTBRAC auxprogram main . RGTBRAC

    RGTBRAC         shift and go to state 28


state 22

    (82) vars -> type varsaux2 . SEMICOLON

    SEMICOLON       shift and go to state 29


state 23

    (86) varsaux2 -> ID . EQUAL varsaux constant
    (87) varsaux2 -> ID . EQUAL varsaux constant COMMA varsaux2
    (88) varsaux2 -> ID . LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues
    (89) varsaux2 -> ID . LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2

    EQUAL           shift and go to state 31
    LFTBRACSQR      shift and go to state 30


state 24

    (3) auxprogram -> function auxprogram .

    PRIOMH          reduce using rule 3 (auxprogram -> function auxprogram .)


state 25

    (77) function -> FUNCTION functionaux ID . LFTPAREN functionaux2 RGTPAREN blockreturn

    LFTPAREN        shift and go to state 32


state 26

    (19) block -> LFTBRAC . blockaux RGTBRAC
    (20) blockaux -> . statement blockaux
    (21) blockaux -> . empty
    (64) statement -> . assignment
    (65) statement -> . condition
    (66) statement -> . vars
    (67) statement -> . loop
    (68) statement -> . write
    (69) statement -> . read
    (70) statement -> . call
    (93) empty -> .
    (11) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (12) assignment -> . assignmentaux EQUAL call SEMICOLON
    (22) condition -> . IF conditionaux
    (23) condition -> . IF conditionaux ELSE block
    (82) vars -> . type varsaux2 SEMICOLON
    (55) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (56) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (92) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (90) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (13) assignmentaux -> . ID
    (14) assignmentaux -> . array
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 93 (empty -> .)
    IF              shift and go to state 48
    WHILE           shift and go to state 35
    PRINT           shift and go to state 36
    READ            shift and go to state 34
    ID              shift and go to state 46
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    type                           shift and go to state 9
    vars                           shift and go to state 33
    read                           shift and go to state 39
    assignment                     shift and go to state 44
    write                          shift and go to state 38
    assignmentaux                  shift and go to state 45
    call                           shift and go to state 40
    empty                          shift and go to state 42
    statement                      shift and go to state 41
    loop                           shift and go to state 49
    array                          shift and go to state 37
    condition                      shift and go to state 47
    blockaux                       shift and go to state 43

state 27

    (76) main -> PRIOMH block .

    RGTBRAC         reduce using rule 76 (main -> PRIOMH block .)


state 28

    (1) program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC .

    $end            reduce using rule 1 (program -> PROGRAM ID LFTBRAC auxprogram main RGTBRAC .)


state 29

    (82) vars -> type varsaux2 SEMICOLON .

    IF              reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    WHILE           reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    PRINT           reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    READ            reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    ID              reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    INT             reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    FLOAT           reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    CHAR            reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    BOOL            reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    STRING          reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    RGTBRAC         reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    FUNCTION        reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    PRIOMH          reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)
    RETURN          reduce using rule 82 (vars -> type varsaux2 SEMICOLON .)


state 30

    (88) varsaux2 -> ID LFTBRACSQR . INT RGTBRACSQR EQUAL arrayvalues
    (89) varsaux2 -> ID LFTBRACSQR . INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2

    INT             shift and go to state 50


state 31

    (86) varsaux2 -> ID EQUAL . varsaux constant
    (87) varsaux2 -> ID EQUAL . varsaux constant COMMA varsaux2
    (83) varsaux -> . PLUS
    (84) varsaux -> . MINUS
    (85) varsaux -> . empty
    (93) empty -> .

    PLUS            shift and go to state 52
    MINUS           shift and go to state 51
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    empty                          shift and go to state 53
    varsaux                        shift and go to state 54

state 32

    (77) function -> FUNCTION functionaux ID LFTPAREN . functionaux2 RGTPAREN blockreturn
    (80) functionaux2 -> . parameter
    (81) functionaux2 -> . empty
    (57) parameter -> . type ID
    (58) parameter -> . type ID COMMA parameter
    (59) parameter -> . empty
    (93) empty -> .
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING

    RGTPAREN        reduce using rule 93 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    type                           shift and go to state 55
    functionaux2                   shift and go to state 56
    parameter                      shift and go to state 57
    empty                          shift and go to state 58

state 33

    (66) statement -> vars .

    IF              reduce using rule 66 (statement -> vars .)
    WHILE           reduce using rule 66 (statement -> vars .)
    PRINT           reduce using rule 66 (statement -> vars .)
    READ            reduce using rule 66 (statement -> vars .)
    ID              reduce using rule 66 (statement -> vars .)
    INT             reduce using rule 66 (statement -> vars .)
    FLOAT           reduce using rule 66 (statement -> vars .)
    CHAR            reduce using rule 66 (statement -> vars .)
    BOOL            reduce using rule 66 (statement -> vars .)
    STRING          reduce using rule 66 (statement -> vars .)
    RGTBRAC         reduce using rule 66 (statement -> vars .)
    RETURN          reduce using rule 66 (statement -> vars .)


state 34

    (92) read -> READ . LFTPAREN ID RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 59


state 35

    (55) loop -> WHILE . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 60


state 36

    (56) write -> PRINT . LFTPAREN constant RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 61


state 37

    (14) assignmentaux -> array .

    EQUAL           reduce using rule 14 (assignmentaux -> array .)


state 38

    (68) statement -> write .

    IF              reduce using rule 68 (statement -> write .)
    WHILE           reduce using rule 68 (statement -> write .)
    PRINT           reduce using rule 68 (statement -> write .)
    READ            reduce using rule 68 (statement -> write .)
    ID              reduce using rule 68 (statement -> write .)
    INT             reduce using rule 68 (statement -> write .)
    FLOAT           reduce using rule 68 (statement -> write .)
    CHAR            reduce using rule 68 (statement -> write .)
    BOOL            reduce using rule 68 (statement -> write .)
    STRING          reduce using rule 68 (statement -> write .)
    RGTBRAC         reduce using rule 68 (statement -> write .)
    RETURN          reduce using rule 68 (statement -> write .)


state 39

    (69) statement -> read .

    IF              reduce using rule 69 (statement -> read .)
    WHILE           reduce using rule 69 (statement -> read .)
    PRINT           reduce using rule 69 (statement -> read .)
    READ            reduce using rule 69 (statement -> read .)
    ID              reduce using rule 69 (statement -> read .)
    INT             reduce using rule 69 (statement -> read .)
    FLOAT           reduce using rule 69 (statement -> read .)
    CHAR            reduce using rule 69 (statement -> read .)
    BOOL            reduce using rule 69 (statement -> read .)
    STRING          reduce using rule 69 (statement -> read .)
    RGTBRAC         reduce using rule 69 (statement -> read .)
    RETURN          reduce using rule 69 (statement -> read .)


state 40

    (70) statement -> call .

    IF              reduce using rule 70 (statement -> call .)
    WHILE           reduce using rule 70 (statement -> call .)
    PRINT           reduce using rule 70 (statement -> call .)
    READ            reduce using rule 70 (statement -> call .)
    ID              reduce using rule 70 (statement -> call .)
    INT             reduce using rule 70 (statement -> call .)
    FLOAT           reduce using rule 70 (statement -> call .)
    CHAR            reduce using rule 70 (statement -> call .)
    BOOL            reduce using rule 70 (statement -> call .)
    STRING          reduce using rule 70 (statement -> call .)
    RGTBRAC         reduce using rule 70 (statement -> call .)
    RETURN          reduce using rule 70 (statement -> call .)


state 41

    (20) blockaux -> statement . blockaux
    (20) blockaux -> . statement blockaux
    (21) blockaux -> . empty
    (64) statement -> . assignment
    (65) statement -> . condition
    (66) statement -> . vars
    (67) statement -> . loop
    (68) statement -> . write
    (69) statement -> . read
    (70) statement -> . call
    (93) empty -> .
    (11) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (12) assignment -> . assignmentaux EQUAL call SEMICOLON
    (22) condition -> . IF conditionaux
    (23) condition -> . IF conditionaux ELSE block
    (82) vars -> . type varsaux2 SEMICOLON
    (55) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (56) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (92) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (90) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (13) assignmentaux -> . ID
    (14) assignmentaux -> . array
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 93 (empty -> .)
    IF              shift and go to state 48
    WHILE           shift and go to state 35
    PRINT           shift and go to state 36
    READ            shift and go to state 34
    ID              shift and go to state 46
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    type                           shift and go to state 9
    vars                           shift and go to state 33
    read                           shift and go to state 39
    assignment                     shift and go to state 44
    write                          shift and go to state 38
    assignmentaux                  shift and go to state 45
    call                           shift and go to state 40
    empty                          shift and go to state 42
    statement                      shift and go to state 41
    loop                           shift and go to state 49
    array                          shift and go to state 37
    condition                      shift and go to state 47
    blockaux                       shift and go to state 62

state 42

    (21) blockaux -> empty .

    RGTBRAC         reduce using rule 21 (blockaux -> empty .)


state 43

    (19) block -> LFTBRAC blockaux . RGTBRAC

    RGTBRAC         shift and go to state 63


state 44

    (64) statement -> assignment .

    IF              reduce using rule 64 (statement -> assignment .)
    WHILE           reduce using rule 64 (statement -> assignment .)
    PRINT           reduce using rule 64 (statement -> assignment .)
    READ            reduce using rule 64 (statement -> assignment .)
    ID              reduce using rule 64 (statement -> assignment .)
    INT             reduce using rule 64 (statement -> assignment .)
    FLOAT           reduce using rule 64 (statement -> assignment .)
    CHAR            reduce using rule 64 (statement -> assignment .)
    BOOL            reduce using rule 64 (statement -> assignment .)
    STRING          reduce using rule 64 (statement -> assignment .)
    RGTBRAC         reduce using rule 64 (statement -> assignment .)
    RETURN          reduce using rule 64 (statement -> assignment .)


state 45

    (11) assignment -> assignmentaux . EQUAL expression SEMICOLON
    (12) assignment -> assignmentaux . EQUAL call SEMICOLON

    EQUAL           shift and go to state 64


state 46

    (90) call -> ID . LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> ID . LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (13) assignmentaux -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR

    LFTPAREN        shift and go to state 65
    EQUAL           reduce using rule 13 (assignmentaux -> ID .)
    LFTBRACSQR      shift and go to state 66


state 47

    (65) statement -> condition .

    IF              reduce using rule 65 (statement -> condition .)
    WHILE           reduce using rule 65 (statement -> condition .)
    PRINT           reduce using rule 65 (statement -> condition .)
    READ            reduce using rule 65 (statement -> condition .)
    ID              reduce using rule 65 (statement -> condition .)
    INT             reduce using rule 65 (statement -> condition .)
    FLOAT           reduce using rule 65 (statement -> condition .)
    CHAR            reduce using rule 65 (statement -> condition .)
    BOOL            reduce using rule 65 (statement -> condition .)
    STRING          reduce using rule 65 (statement -> condition .)
    RGTBRAC         reduce using rule 65 (statement -> condition .)
    RETURN          reduce using rule 65 (statement -> condition .)


state 48

    (22) condition -> IF . conditionaux
    (23) condition -> IF . conditionaux ELSE block
    (24) conditionaux -> . LFTPAREN expression RGTPAREN block ELSEIF conditionaux
    (25) conditionaux -> . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 67

    conditionaux                   shift and go to state 68

state 49

    (67) statement -> loop .

    IF              reduce using rule 67 (statement -> loop .)
    WHILE           reduce using rule 67 (statement -> loop .)
    PRINT           reduce using rule 67 (statement -> loop .)
    READ            reduce using rule 67 (statement -> loop .)
    ID              reduce using rule 67 (statement -> loop .)
    INT             reduce using rule 67 (statement -> loop .)
    FLOAT           reduce using rule 67 (statement -> loop .)
    CHAR            reduce using rule 67 (statement -> loop .)
    BOOL            reduce using rule 67 (statement -> loop .)
    STRING          reduce using rule 67 (statement -> loop .)
    RGTBRAC         reduce using rule 67 (statement -> loop .)
    RETURN          reduce using rule 67 (statement -> loop .)


state 50

    (88) varsaux2 -> ID LFTBRACSQR INT . RGTBRACSQR EQUAL arrayvalues
    (89) varsaux2 -> ID LFTBRACSQR INT . RGTBRACSQR EQUAL arrayvalues COMMA varsaux2

    RGTBRACSQR      shift and go to state 69


state 51

    (84) varsaux -> MINUS .

    ID              reduce using rule 84 (varsaux -> MINUS .)
    TRUE            reduce using rule 84 (varsaux -> MINUS .)
    FALSE           reduce using rule 84 (varsaux -> MINUS .)
    FLOAT           reduce using rule 84 (varsaux -> MINUS .)
    INT             reduce using rule 84 (varsaux -> MINUS .)
    STRING          reduce using rule 84 (varsaux -> MINUS .)


state 52

    (83) varsaux -> PLUS .

    ID              reduce using rule 83 (varsaux -> PLUS .)
    TRUE            reduce using rule 83 (varsaux -> PLUS .)
    FALSE           reduce using rule 83 (varsaux -> PLUS .)
    FLOAT           reduce using rule 83 (varsaux -> PLUS .)
    INT             reduce using rule 83 (varsaux -> PLUS .)
    STRING          reduce using rule 83 (varsaux -> PLUS .)


state 53

    (85) varsaux -> empty .

    ID              reduce using rule 85 (varsaux -> empty .)
    TRUE            reduce using rule 85 (varsaux -> empty .)
    FALSE           reduce using rule 85 (varsaux -> empty .)
    FLOAT           reduce using rule 85 (varsaux -> empty .)
    INT             reduce using rule 85 (varsaux -> empty .)
    STRING          reduce using rule 85 (varsaux -> empty .)


state 54

    (86) varsaux2 -> ID EQUAL varsaux . constant
    (87) varsaux2 -> ID EQUAL varsaux . constant COMMA varsaux2
    (26) constant -> . ID
    (27) constant -> . array
    (28) constant -> . cteN
    (29) constant -> . cteS
    (30) constant -> . TRUE
    (31) constant -> . FALSE
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (32) cteN -> . FLOAT
    (33) cteN -> . INT
    (34) cteS -> . STRING

    ID              shift and go to state 79
    TRUE            shift and go to state 74
    FALSE           shift and go to state 76
    FLOAT           shift and go to state 75
    INT             shift and go to state 73
    STRING          shift and go to state 72

    cteS                           shift and go to state 70
    constant                       shift and go to state 71
    array                          shift and go to state 77
    cteN                           shift and go to state 78

state 55

    (57) parameter -> type . ID
    (58) parameter -> type . ID COMMA parameter

    ID              shift and go to state 80


state 56

    (77) function -> FUNCTION functionaux ID LFTPAREN functionaux2 . RGTPAREN blockreturn

    RGTPAREN        shift and go to state 81


state 57

    (80) functionaux2 -> parameter .

    RGTPAREN        reduce using rule 80 (functionaux2 -> parameter .)


state 58

    (81) functionaux2 -> empty .
    (59) parameter -> empty .

  ! reduce/reduce conflict for RGTPAREN resolved using rule 59 (parameter -> empty .)
    RGTPAREN        reduce using rule 59 (parameter -> empty .)

  ! RGTPAREN        [ reduce using rule 81 (functionaux2 -> empty .) ]


state 59

    (92) read -> READ LFTPAREN . ID RGTPAREN SEMICOLON

    ID              shift and go to state 82


state 60

    (55) loop -> WHILE LFTPAREN . expression RGTPAREN block
    (45) expression -> . exp
    (46) expression -> . exp expressionaux exp
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    empty                          shift and go to state 86
    exp                            shift and go to state 87
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    expression                     shift and go to state 90

state 61

    (56) write -> PRINT LFTPAREN . constant RGTPAREN SEMICOLON
    (26) constant -> . ID
    (27) constant -> . array
    (28) constant -> . cteN
    (29) constant -> . cteS
    (30) constant -> . TRUE
    (31) constant -> . FALSE
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (32) cteN -> . FLOAT
    (33) cteN -> . INT
    (34) cteS -> . STRING

    ID              shift and go to state 79
    TRUE            shift and go to state 74
    FALSE           shift and go to state 76
    FLOAT           shift and go to state 75
    INT             shift and go to state 73
    STRING          shift and go to state 72

    cteN                           shift and go to state 78
    array                          shift and go to state 77
    constant                       shift and go to state 92
    cteS                           shift and go to state 70

state 62

    (20) blockaux -> statement blockaux .

    RGTBRAC         reduce using rule 20 (blockaux -> statement blockaux .)


state 63

    (19) block -> LFTBRAC blockaux RGTBRAC .

    ELSEIF          reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    ELSE            reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    IF              reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    WHILE           reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    PRINT           reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    READ            reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    ID              reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    INT             reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    FLOAT           reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    CHAR            reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    BOOL            reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    STRING          reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    RGTBRAC         reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)
    RETURN          reduce using rule 19 (block -> LFTBRAC blockaux RGTBRAC .)


state 64

    (11) assignment -> assignmentaux EQUAL . expression SEMICOLON
    (12) assignment -> assignmentaux EQUAL . call SEMICOLON
    (45) expression -> . exp
    (46) expression -> . exp expressionaux exp
    (90) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 95
    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

  ! ID              [ reduce using rule 93 (empty -> .) ]

    term                           shift and go to state 83
    call                           shift and go to state 93
    exp                            shift and go to state 87
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    expression                     shift and go to state 94
    empty                          shift and go to state 86

state 65

    (90) call -> ID LFTPAREN . exp RGTPAREN SEMICOLON
    (91) call -> ID LFTPAREN . exp COMMA call RGTPAREN SEMICOLON
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 96
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 66

    (5) array -> ID LFTBRACSQR . exp RGTBRACSQR
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 97
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 67

    (24) conditionaux -> LFTPAREN . expression RGTPAREN block ELSEIF conditionaux
    (25) conditionaux -> LFTPAREN . expression RGTPAREN block
    (45) expression -> . exp
    (46) expression -> . exp expressionaux exp
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    empty                          shift and go to state 86
    exp                            shift and go to state 87
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    expression                     shift and go to state 98

state 68

    (22) condition -> IF conditionaux .
    (23) condition -> IF conditionaux . ELSE block

    IF              reduce using rule 22 (condition -> IF conditionaux .)
    WHILE           reduce using rule 22 (condition -> IF conditionaux .)
    PRINT           reduce using rule 22 (condition -> IF conditionaux .)
    READ            reduce using rule 22 (condition -> IF conditionaux .)
    ID              reduce using rule 22 (condition -> IF conditionaux .)
    INT             reduce using rule 22 (condition -> IF conditionaux .)
    FLOAT           reduce using rule 22 (condition -> IF conditionaux .)
    CHAR            reduce using rule 22 (condition -> IF conditionaux .)
    BOOL            reduce using rule 22 (condition -> IF conditionaux .)
    STRING          reduce using rule 22 (condition -> IF conditionaux .)
    RGTBRAC         reduce using rule 22 (condition -> IF conditionaux .)
    RETURN          reduce using rule 22 (condition -> IF conditionaux .)
    ELSE            shift and go to state 99


state 69

    (88) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR . EQUAL arrayvalues
    (89) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR . EQUAL arrayvalues COMMA varsaux2

    EQUAL           shift and go to state 100


state 70

    (29) constant -> cteS .

    MULTIPLICATION  reduce using rule 29 (constant -> cteS .)
    DIVISION        reduce using rule 29 (constant -> cteS .)
    PLUS            reduce using rule 29 (constant -> cteS .)
    MINUS           reduce using rule 29 (constant -> cteS .)
    AND             reduce using rule 29 (constant -> cteS .)
    DOUBEQUAL       reduce using rule 29 (constant -> cteS .)
    NOT             reduce using rule 29 (constant -> cteS .)
    OR              reduce using rule 29 (constant -> cteS .)
    LESSTHANEQUAL   reduce using rule 29 (constant -> cteS .)
    GREATTHANEQUAL  reduce using rule 29 (constant -> cteS .)
    GREATTHAN       reduce using rule 29 (constant -> cteS .)
    LESSTHAN        reduce using rule 29 (constant -> cteS .)
    RGTPAREN        reduce using rule 29 (constant -> cteS .)
    SEMICOLON       reduce using rule 29 (constant -> cteS .)
    COMMA           reduce using rule 29 (constant -> cteS .)
    RGTBRACSQR      reduce using rule 29 (constant -> cteS .)


state 71

    (86) varsaux2 -> ID EQUAL varsaux constant .
    (87) varsaux2 -> ID EQUAL varsaux constant . COMMA varsaux2

    SEMICOLON       reduce using rule 86 (varsaux2 -> ID EQUAL varsaux constant .)
    COMMA           shift and go to state 101


state 72

    (34) cteS -> STRING .

    COMMA           reduce using rule 34 (cteS -> STRING .)
    RGTBRACSQR      reduce using rule 34 (cteS -> STRING .)
    RGTPAREN        reduce using rule 34 (cteS -> STRING .)
    MULTIPLICATION  reduce using rule 34 (cteS -> STRING .)
    DIVISION        reduce using rule 34 (cteS -> STRING .)
    PLUS            reduce using rule 34 (cteS -> STRING .)
    MINUS           reduce using rule 34 (cteS -> STRING .)
    AND             reduce using rule 34 (cteS -> STRING .)
    DOUBEQUAL       reduce using rule 34 (cteS -> STRING .)
    NOT             reduce using rule 34 (cteS -> STRING .)
    OR              reduce using rule 34 (cteS -> STRING .)
    LESSTHANEQUAL   reduce using rule 34 (cteS -> STRING .)
    GREATTHANEQUAL  reduce using rule 34 (cteS -> STRING .)
    GREATTHAN       reduce using rule 34 (cteS -> STRING .)
    LESSTHAN        reduce using rule 34 (cteS -> STRING .)
    SEMICOLON       reduce using rule 34 (cteS -> STRING .)


state 73

    (33) cteN -> INT .

    COMMA           reduce using rule 33 (cteN -> INT .)
    SEMICOLON       reduce using rule 33 (cteN -> INT .)
    RGTBRACSQR      reduce using rule 33 (cteN -> INT .)
    MULTIPLICATION  reduce using rule 33 (cteN -> INT .)
    DIVISION        reduce using rule 33 (cteN -> INT .)
    PLUS            reduce using rule 33 (cteN -> INT .)
    MINUS           reduce using rule 33 (cteN -> INT .)
    AND             reduce using rule 33 (cteN -> INT .)
    DOUBEQUAL       reduce using rule 33 (cteN -> INT .)
    NOT             reduce using rule 33 (cteN -> INT .)
    OR              reduce using rule 33 (cteN -> INT .)
    LESSTHANEQUAL   reduce using rule 33 (cteN -> INT .)
    GREATTHANEQUAL  reduce using rule 33 (cteN -> INT .)
    GREATTHAN       reduce using rule 33 (cteN -> INT .)
    LESSTHAN        reduce using rule 33 (cteN -> INT .)
    RGTPAREN        reduce using rule 33 (cteN -> INT .)


state 74

    (30) constant -> TRUE .

    MULTIPLICATION  reduce using rule 30 (constant -> TRUE .)
    DIVISION        reduce using rule 30 (constant -> TRUE .)
    PLUS            reduce using rule 30 (constant -> TRUE .)
    MINUS           reduce using rule 30 (constant -> TRUE .)
    AND             reduce using rule 30 (constant -> TRUE .)
    DOUBEQUAL       reduce using rule 30 (constant -> TRUE .)
    NOT             reduce using rule 30 (constant -> TRUE .)
    OR              reduce using rule 30 (constant -> TRUE .)
    LESSTHANEQUAL   reduce using rule 30 (constant -> TRUE .)
    GREATTHANEQUAL  reduce using rule 30 (constant -> TRUE .)
    GREATTHAN       reduce using rule 30 (constant -> TRUE .)
    LESSTHAN        reduce using rule 30 (constant -> TRUE .)
    RGTPAREN        reduce using rule 30 (constant -> TRUE .)
    SEMICOLON       reduce using rule 30 (constant -> TRUE .)
    COMMA           reduce using rule 30 (constant -> TRUE .)
    RGTBRACSQR      reduce using rule 30 (constant -> TRUE .)


state 75

    (32) cteN -> FLOAT .

    COMMA           reduce using rule 32 (cteN -> FLOAT .)
    SEMICOLON       reduce using rule 32 (cteN -> FLOAT .)
    RGTBRACSQR      reduce using rule 32 (cteN -> FLOAT .)
    MULTIPLICATION  reduce using rule 32 (cteN -> FLOAT .)
    DIVISION        reduce using rule 32 (cteN -> FLOAT .)
    PLUS            reduce using rule 32 (cteN -> FLOAT .)
    MINUS           reduce using rule 32 (cteN -> FLOAT .)
    AND             reduce using rule 32 (cteN -> FLOAT .)
    DOUBEQUAL       reduce using rule 32 (cteN -> FLOAT .)
    NOT             reduce using rule 32 (cteN -> FLOAT .)
    OR              reduce using rule 32 (cteN -> FLOAT .)
    LESSTHANEQUAL   reduce using rule 32 (cteN -> FLOAT .)
    GREATTHANEQUAL  reduce using rule 32 (cteN -> FLOAT .)
    GREATTHAN       reduce using rule 32 (cteN -> FLOAT .)
    LESSTHAN        reduce using rule 32 (cteN -> FLOAT .)
    RGTPAREN        reduce using rule 32 (cteN -> FLOAT .)


state 76

    (31) constant -> FALSE .

    MULTIPLICATION  reduce using rule 31 (constant -> FALSE .)
    DIVISION        reduce using rule 31 (constant -> FALSE .)
    PLUS            reduce using rule 31 (constant -> FALSE .)
    MINUS           reduce using rule 31 (constant -> FALSE .)
    AND             reduce using rule 31 (constant -> FALSE .)
    DOUBEQUAL       reduce using rule 31 (constant -> FALSE .)
    NOT             reduce using rule 31 (constant -> FALSE .)
    OR              reduce using rule 31 (constant -> FALSE .)
    LESSTHANEQUAL   reduce using rule 31 (constant -> FALSE .)
    GREATTHANEQUAL  reduce using rule 31 (constant -> FALSE .)
    GREATTHAN       reduce using rule 31 (constant -> FALSE .)
    LESSTHAN        reduce using rule 31 (constant -> FALSE .)
    RGTPAREN        reduce using rule 31 (constant -> FALSE .)
    SEMICOLON       reduce using rule 31 (constant -> FALSE .)
    COMMA           reduce using rule 31 (constant -> FALSE .)
    RGTBRACSQR      reduce using rule 31 (constant -> FALSE .)


state 77

    (27) constant -> array .

    MULTIPLICATION  reduce using rule 27 (constant -> array .)
    DIVISION        reduce using rule 27 (constant -> array .)
    PLUS            reduce using rule 27 (constant -> array .)
    MINUS           reduce using rule 27 (constant -> array .)
    AND             reduce using rule 27 (constant -> array .)
    DOUBEQUAL       reduce using rule 27 (constant -> array .)
    NOT             reduce using rule 27 (constant -> array .)
    OR              reduce using rule 27 (constant -> array .)
    LESSTHANEQUAL   reduce using rule 27 (constant -> array .)
    GREATTHANEQUAL  reduce using rule 27 (constant -> array .)
    GREATTHAN       reduce using rule 27 (constant -> array .)
    LESSTHAN        reduce using rule 27 (constant -> array .)
    RGTPAREN        reduce using rule 27 (constant -> array .)
    SEMICOLON       reduce using rule 27 (constant -> array .)
    COMMA           reduce using rule 27 (constant -> array .)
    RGTBRACSQR      reduce using rule 27 (constant -> array .)


state 78

    (28) constant -> cteN .

    MULTIPLICATION  reduce using rule 28 (constant -> cteN .)
    DIVISION        reduce using rule 28 (constant -> cteN .)
    PLUS            reduce using rule 28 (constant -> cteN .)
    MINUS           reduce using rule 28 (constant -> cteN .)
    AND             reduce using rule 28 (constant -> cteN .)
    DOUBEQUAL       reduce using rule 28 (constant -> cteN .)
    NOT             reduce using rule 28 (constant -> cteN .)
    OR              reduce using rule 28 (constant -> cteN .)
    LESSTHANEQUAL   reduce using rule 28 (constant -> cteN .)
    GREATTHANEQUAL  reduce using rule 28 (constant -> cteN .)
    GREATTHAN       reduce using rule 28 (constant -> cteN .)
    LESSTHAN        reduce using rule 28 (constant -> cteN .)
    RGTPAREN        reduce using rule 28 (constant -> cteN .)
    SEMICOLON       reduce using rule 28 (constant -> cteN .)
    COMMA           reduce using rule 28 (constant -> cteN .)
    RGTBRACSQR      reduce using rule 28 (constant -> cteN .)


state 79

    (26) constant -> ID .
    (5) array -> ID . LFTBRACSQR exp RGTBRACSQR

    MULTIPLICATION  reduce using rule 26 (constant -> ID .)
    DIVISION        reduce using rule 26 (constant -> ID .)
    PLUS            reduce using rule 26 (constant -> ID .)
    MINUS           reduce using rule 26 (constant -> ID .)
    AND             reduce using rule 26 (constant -> ID .)
    DOUBEQUAL       reduce using rule 26 (constant -> ID .)
    NOT             reduce using rule 26 (constant -> ID .)
    OR              reduce using rule 26 (constant -> ID .)
    LESSTHANEQUAL   reduce using rule 26 (constant -> ID .)
    GREATTHANEQUAL  reduce using rule 26 (constant -> ID .)
    GREATTHAN       reduce using rule 26 (constant -> ID .)
    LESSTHAN        reduce using rule 26 (constant -> ID .)
    RGTPAREN        reduce using rule 26 (constant -> ID .)
    SEMICOLON       reduce using rule 26 (constant -> ID .)
    COMMA           reduce using rule 26 (constant -> ID .)
    RGTBRACSQR      reduce using rule 26 (constant -> ID .)
    LFTBRACSQR      shift and go to state 66


state 80

    (57) parameter -> type ID .
    (58) parameter -> type ID . COMMA parameter

    RGTPAREN        reduce using rule 57 (parameter -> type ID .)
    COMMA           shift and go to state 102


state 81

    (77) function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN . blockreturn
    (15) blockreturn -> . LFTBRAC blockreturnaux RGTBRAC
    (16) blockreturn -> . LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC

    LFTBRAC         shift and go to state 103

    blockreturn                    shift and go to state 104

state 82

    (92) read -> READ LFTPAREN ID . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 105


state 83

    (35) exp -> term .
    (36) exp -> term . expaux
    (37) expaux -> . PLUS exp expaux
    (38) expaux -> . MINUS exp expaux
    (39) expaux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for DOUBEQUAL resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for NOT resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for OR resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for LESSTHANEQUAL resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for GREATTHANEQUAL resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for GREATTHAN resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for LESSTHAN resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for RGTPAREN resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for COMMA resolved using rule 35 (exp -> term .)
  ! reduce/reduce conflict for RGTBRACSQR resolved using rule 35 (exp -> term .)
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    AND             reduce using rule 35 (exp -> term .)
    DOUBEQUAL       reduce using rule 35 (exp -> term .)
    NOT             reduce using rule 35 (exp -> term .)
    OR              reduce using rule 35 (exp -> term .)
    LESSTHANEQUAL   reduce using rule 35 (exp -> term .)
    GREATTHANEQUAL  reduce using rule 35 (exp -> term .)
    GREATTHAN       reduce using rule 35 (exp -> term .)
    LESSTHAN        reduce using rule 35 (exp -> term .)
    RGTPAREN        reduce using rule 35 (exp -> term .)
    SEMICOLON       reduce using rule 35 (exp -> term .)
    COMMA           reduce using rule 35 (exp -> term .)
    RGTBRACSQR      reduce using rule 35 (exp -> term .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108

  ! PLUS            [ reduce using rule 35 (exp -> term .) ]
  ! MINUS           [ reduce using rule 35 (exp -> term .) ]
  ! AND             [ reduce using rule 93 (empty -> .) ]
  ! DOUBEQUAL       [ reduce using rule 93 (empty -> .) ]
  ! NOT             [ reduce using rule 93 (empty -> .) ]
  ! OR              [ reduce using rule 93 (empty -> .) ]
  ! LESSTHANEQUAL   [ reduce using rule 93 (empty -> .) ]
  ! GREATTHANEQUAL  [ reduce using rule 93 (empty -> .) ]
  ! GREATTHAN       [ reduce using rule 93 (empty -> .) ]
  ! LESSTHAN        [ reduce using rule 93 (empty -> .) ]
  ! RGTPAREN        [ reduce using rule 93 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 93 (empty -> .) ]
  ! COMMA           [ reduce using rule 93 (empty -> .) ]
  ! RGTBRACSQR      [ reduce using rule 93 (empty -> .) ]
  ! PLUS            [ reduce using rule 93 (empty -> .) ]
  ! MINUS           [ reduce using rule 93 (empty -> .) ]

    expaux                         shift and go to state 106
    empty                          shift and go to state 109

state 84

    (41) factor -> LFTPAREN . expression RGTPAREN
    (45) expression -> . exp
    (46) expression -> . exp expressionaux exp
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 87
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    expression                     shift and go to state 110
    empty                          shift and go to state 86

state 85

    (42) factoraux -> PLUS .

    ID              reduce using rule 42 (factoraux -> PLUS .)
    TRUE            reduce using rule 42 (factoraux -> PLUS .)
    FALSE           reduce using rule 42 (factoraux -> PLUS .)
    FLOAT           reduce using rule 42 (factoraux -> PLUS .)
    INT             reduce using rule 42 (factoraux -> PLUS .)
    STRING          reduce using rule 42 (factoraux -> PLUS .)


state 86

    (44) factoraux -> empty .

    ID              reduce using rule 44 (factoraux -> empty .)
    TRUE            reduce using rule 44 (factoraux -> empty .)
    FALSE           reduce using rule 44 (factoraux -> empty .)
    FLOAT           reduce using rule 44 (factoraux -> empty .)
    INT             reduce using rule 44 (factoraux -> empty .)
    STRING          reduce using rule 44 (factoraux -> empty .)


state 87

    (45) expression -> exp .
    (46) expression -> exp . expressionaux exp
    (47) expressionaux -> . AND
    (48) expressionaux -> . DOUBEQUAL
    (49) expressionaux -> . NOT
    (50) expressionaux -> . OR
    (51) expressionaux -> . LESSTHANEQUAL
    (52) expressionaux -> . GREATTHANEQUAL
    (53) expressionaux -> . GREATTHAN
    (54) expressionaux -> . LESSTHAN

    RGTPAREN        reduce using rule 45 (expression -> exp .)
    SEMICOLON       reduce using rule 45 (expression -> exp .)
    AND             shift and go to state 111
    DOUBEQUAL       shift and go to state 118
    NOT             shift and go to state 117
    OR              shift and go to state 119
    LESSTHANEQUAL   shift and go to state 115
    GREATTHANEQUAL  shift and go to state 113
    GREATTHAN       shift and go to state 114
    LESSTHAN        shift and go to state 116

    expressionaux                  shift and go to state 112

state 88

    (60) term -> factor . termaux
    (61) termaux -> . MULTIPLICATION term termaux
    (62) termaux -> . DIVISION term termaux
    (63) termaux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 121
    DIVISION        shift and go to state 120
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    DOUBEQUAL       reduce using rule 93 (empty -> .)
    NOT             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    LESSTHANEQUAL   reduce using rule 93 (empty -> .)
    GREATTHANEQUAL  reduce using rule 93 (empty -> .)
    GREATTHAN       reduce using rule 93 (empty -> .)
    LESSTHAN        reduce using rule 93 (empty -> .)
    RGTPAREN        reduce using rule 93 (empty -> .)
    SEMICOLON       reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RGTBRACSQR      reduce using rule 93 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 93 (empty -> .) ]
  ! DIVISION        [ reduce using rule 93 (empty -> .) ]

    termaux                        shift and go to state 122
    empty                          shift and go to state 123

state 89

    (40) factor -> factoraux . constant
    (26) constant -> . ID
    (27) constant -> . array
    (28) constant -> . cteN
    (29) constant -> . cteS
    (30) constant -> . TRUE
    (31) constant -> . FALSE
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR
    (32) cteN -> . FLOAT
    (33) cteN -> . INT
    (34) cteS -> . STRING

    ID              shift and go to state 79
    TRUE            shift and go to state 74
    FALSE           shift and go to state 76
    FLOAT           shift and go to state 75
    INT             shift and go to state 73
    STRING          shift and go to state 72

    cteS                           shift and go to state 70
    constant                       shift and go to state 124
    array                          shift and go to state 77
    cteN                           shift and go to state 78

state 90

    (55) loop -> WHILE LFTPAREN expression . RGTPAREN block

    RGTPAREN        shift and go to state 125


state 91

    (43) factoraux -> MINUS .

    ID              reduce using rule 43 (factoraux -> MINUS .)
    TRUE            reduce using rule 43 (factoraux -> MINUS .)
    FALSE           reduce using rule 43 (factoraux -> MINUS .)
    FLOAT           reduce using rule 43 (factoraux -> MINUS .)
    INT             reduce using rule 43 (factoraux -> MINUS .)
    STRING          reduce using rule 43 (factoraux -> MINUS .)


state 92

    (56) write -> PRINT LFTPAREN constant . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 126


state 93

    (12) assignment -> assignmentaux EQUAL call . SEMICOLON

    SEMICOLON       shift and go to state 127


state 94

    (11) assignment -> assignmentaux EQUAL expression . SEMICOLON

    SEMICOLON       shift and go to state 128


state 95

    (90) call -> ID . LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> ID . LFTPAREN exp COMMA call RGTPAREN SEMICOLON

    LFTPAREN        shift and go to state 65


state 96

    (90) call -> ID LFTPAREN exp . RGTPAREN SEMICOLON
    (91) call -> ID LFTPAREN exp . COMMA call RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 129
    COMMA           shift and go to state 130


state 97

    (5) array -> ID LFTBRACSQR exp . RGTBRACSQR

    RGTBRACSQR      shift and go to state 131


state 98

    (24) conditionaux -> LFTPAREN expression . RGTPAREN block ELSEIF conditionaux
    (25) conditionaux -> LFTPAREN expression . RGTPAREN block

    RGTPAREN        shift and go to state 132


state 99

    (23) condition -> IF conditionaux ELSE . block
    (19) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 133

state 100

    (88) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL . arrayvalues
    (89) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL . arrayvalues COMMA varsaux2
    (6) arrayvalues -> . LFTBRACSQR arrayvaluesaux RGTBRACSQR

    LFTBRACSQR      shift and go to state 134

    arrayvalues                    shift and go to state 135

state 101

    (87) varsaux2 -> ID EQUAL varsaux constant COMMA . varsaux2
    (86) varsaux2 -> . ID EQUAL varsaux constant
    (87) varsaux2 -> . ID EQUAL varsaux constant COMMA varsaux2
    (88) varsaux2 -> . ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues
    (89) varsaux2 -> . ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2

    ID              shift and go to state 23

    varsaux2                       shift and go to state 136

state 102

    (58) parameter -> type ID COMMA . parameter
    (57) parameter -> . type ID
    (58) parameter -> . type ID COMMA parameter
    (59) parameter -> . empty
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING
    (93) empty -> .

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12
    RGTPAREN        reduce using rule 93 (empty -> .)

    parameter                      shift and go to state 137
    type                           shift and go to state 55
    empty                          shift and go to state 138

state 103

    (15) blockreturn -> LFTBRAC . blockreturnaux RGTBRAC
    (16) blockreturn -> LFTBRAC . blockreturnaux RETURN exp SEMICOLON RGTBRAC
    (17) blockreturnaux -> . statement blockreturnaux
    (18) blockreturnaux -> . empty
    (64) statement -> . assignment
    (65) statement -> . condition
    (66) statement -> . vars
    (67) statement -> . loop
    (68) statement -> . write
    (69) statement -> . read
    (70) statement -> . call
    (93) empty -> .
    (11) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (12) assignment -> . assignmentaux EQUAL call SEMICOLON
    (22) condition -> . IF conditionaux
    (23) condition -> . IF conditionaux ELSE block
    (82) vars -> . type varsaux2 SEMICOLON
    (55) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (56) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (92) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (90) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (13) assignmentaux -> . ID
    (14) assignmentaux -> . array
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    IF              shift and go to state 48
    WHILE           shift and go to state 35
    PRINT           shift and go to state 36
    READ            shift and go to state 34
    ID              shift and go to state 46
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    loop                           shift and go to state 49
    type                           shift and go to state 9
    vars                           shift and go to state 33
    read                           shift and go to state 39
    assignment                     shift and go to state 44
    write                          shift and go to state 38
    assignmentaux                  shift and go to state 45
    call                           shift and go to state 40
    condition                      shift and go to state 47
    statement                      shift and go to state 139
    blockreturnaux                 shift and go to state 140
    array                          shift and go to state 37
    empty                          shift and go to state 141

state 104

    (77) function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .

    FUNCTION        reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    INT             reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    FLOAT           reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    CHAR            reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    BOOL            reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    STRING          reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)
    PRIOMH          reduce using rule 77 (function -> FUNCTION functionaux ID LFTPAREN functionaux2 RGTPAREN blockreturn .)


state 105

    (92) read -> READ LFTPAREN ID RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 142


state 106

    (36) exp -> term expaux .

    AND             reduce using rule 36 (exp -> term expaux .)
    DOUBEQUAL       reduce using rule 36 (exp -> term expaux .)
    NOT             reduce using rule 36 (exp -> term expaux .)
    OR              reduce using rule 36 (exp -> term expaux .)
    LESSTHANEQUAL   reduce using rule 36 (exp -> term expaux .)
    GREATTHANEQUAL  reduce using rule 36 (exp -> term expaux .)
    GREATTHAN       reduce using rule 36 (exp -> term expaux .)
    LESSTHAN        reduce using rule 36 (exp -> term expaux .)
    RGTPAREN        reduce using rule 36 (exp -> term expaux .)
    SEMICOLON       reduce using rule 36 (exp -> term expaux .)
    COMMA           reduce using rule 36 (exp -> term expaux .)
    RGTBRACSQR      reduce using rule 36 (exp -> term expaux .)
    PLUS            reduce using rule 36 (exp -> term expaux .)
    MINUS           reduce using rule 36 (exp -> term expaux .)


state 107

    (37) expaux -> PLUS . exp expaux
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 143
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 108

    (38) expaux -> MINUS . exp expaux
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 144
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 109

    (39) expaux -> empty .

    AND             reduce using rule 39 (expaux -> empty .)
    DOUBEQUAL       reduce using rule 39 (expaux -> empty .)
    NOT             reduce using rule 39 (expaux -> empty .)
    OR              reduce using rule 39 (expaux -> empty .)
    LESSTHANEQUAL   reduce using rule 39 (expaux -> empty .)
    GREATTHANEQUAL  reduce using rule 39 (expaux -> empty .)
    GREATTHAN       reduce using rule 39 (expaux -> empty .)
    LESSTHAN        reduce using rule 39 (expaux -> empty .)
    RGTPAREN        reduce using rule 39 (expaux -> empty .)
    SEMICOLON       reduce using rule 39 (expaux -> empty .)
    COMMA           reduce using rule 39 (expaux -> empty .)
    RGTBRACSQR      reduce using rule 39 (expaux -> empty .)
    PLUS            reduce using rule 39 (expaux -> empty .)
    MINUS           reduce using rule 39 (expaux -> empty .)


state 110

    (41) factor -> LFTPAREN expression . RGTPAREN

    RGTPAREN        shift and go to state 145


state 111

    (47) expressionaux -> AND .

    LFTPAREN        reduce using rule 47 (expressionaux -> AND .)
    PLUS            reduce using rule 47 (expressionaux -> AND .)
    MINUS           reduce using rule 47 (expressionaux -> AND .)
    ID              reduce using rule 47 (expressionaux -> AND .)
    TRUE            reduce using rule 47 (expressionaux -> AND .)
    FALSE           reduce using rule 47 (expressionaux -> AND .)
    FLOAT           reduce using rule 47 (expressionaux -> AND .)
    INT             reduce using rule 47 (expressionaux -> AND .)
    STRING          reduce using rule 47 (expressionaux -> AND .)


state 112

    (46) expression -> exp expressionaux . exp
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 146
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 113

    (52) expressionaux -> GREATTHANEQUAL .

    LFTPAREN        reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    PLUS            reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    MINUS           reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    ID              reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    TRUE            reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    FALSE           reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    FLOAT           reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    INT             reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)
    STRING          reduce using rule 52 (expressionaux -> GREATTHANEQUAL .)


state 114

    (53) expressionaux -> GREATTHAN .

    LFTPAREN        reduce using rule 53 (expressionaux -> GREATTHAN .)
    PLUS            reduce using rule 53 (expressionaux -> GREATTHAN .)
    MINUS           reduce using rule 53 (expressionaux -> GREATTHAN .)
    ID              reduce using rule 53 (expressionaux -> GREATTHAN .)
    TRUE            reduce using rule 53 (expressionaux -> GREATTHAN .)
    FALSE           reduce using rule 53 (expressionaux -> GREATTHAN .)
    FLOAT           reduce using rule 53 (expressionaux -> GREATTHAN .)
    INT             reduce using rule 53 (expressionaux -> GREATTHAN .)
    STRING          reduce using rule 53 (expressionaux -> GREATTHAN .)


state 115

    (51) expressionaux -> LESSTHANEQUAL .

    LFTPAREN        reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    PLUS            reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    MINUS           reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    ID              reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    TRUE            reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    FALSE           reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    FLOAT           reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    INT             reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)
    STRING          reduce using rule 51 (expressionaux -> LESSTHANEQUAL .)


state 116

    (54) expressionaux -> LESSTHAN .

    LFTPAREN        reduce using rule 54 (expressionaux -> LESSTHAN .)
    PLUS            reduce using rule 54 (expressionaux -> LESSTHAN .)
    MINUS           reduce using rule 54 (expressionaux -> LESSTHAN .)
    ID              reduce using rule 54 (expressionaux -> LESSTHAN .)
    TRUE            reduce using rule 54 (expressionaux -> LESSTHAN .)
    FALSE           reduce using rule 54 (expressionaux -> LESSTHAN .)
    FLOAT           reduce using rule 54 (expressionaux -> LESSTHAN .)
    INT             reduce using rule 54 (expressionaux -> LESSTHAN .)
    STRING          reduce using rule 54 (expressionaux -> LESSTHAN .)


state 117

    (49) expressionaux -> NOT .

    LFTPAREN        reduce using rule 49 (expressionaux -> NOT .)
    PLUS            reduce using rule 49 (expressionaux -> NOT .)
    MINUS           reduce using rule 49 (expressionaux -> NOT .)
    ID              reduce using rule 49 (expressionaux -> NOT .)
    TRUE            reduce using rule 49 (expressionaux -> NOT .)
    FALSE           reduce using rule 49 (expressionaux -> NOT .)
    FLOAT           reduce using rule 49 (expressionaux -> NOT .)
    INT             reduce using rule 49 (expressionaux -> NOT .)
    STRING          reduce using rule 49 (expressionaux -> NOT .)


state 118

    (48) expressionaux -> DOUBEQUAL .

    LFTPAREN        reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    PLUS            reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    MINUS           reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    ID              reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    TRUE            reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    FALSE           reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    FLOAT           reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    INT             reduce using rule 48 (expressionaux -> DOUBEQUAL .)
    STRING          reduce using rule 48 (expressionaux -> DOUBEQUAL .)


state 119

    (50) expressionaux -> OR .

    LFTPAREN        reduce using rule 50 (expressionaux -> OR .)
    PLUS            reduce using rule 50 (expressionaux -> OR .)
    MINUS           reduce using rule 50 (expressionaux -> OR .)
    ID              reduce using rule 50 (expressionaux -> OR .)
    TRUE            reduce using rule 50 (expressionaux -> OR .)
    FALSE           reduce using rule 50 (expressionaux -> OR .)
    FLOAT           reduce using rule 50 (expressionaux -> OR .)
    INT             reduce using rule 50 (expressionaux -> OR .)
    STRING          reduce using rule 50 (expressionaux -> OR .)


state 120

    (62) termaux -> DIVISION . term termaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 147
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 121

    (61) termaux -> MULTIPLICATION . term termaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 148
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 122

    (60) term -> factor termaux .

    PLUS            reduce using rule 60 (term -> factor termaux .)
    MINUS           reduce using rule 60 (term -> factor termaux .)
    AND             reduce using rule 60 (term -> factor termaux .)
    DOUBEQUAL       reduce using rule 60 (term -> factor termaux .)
    NOT             reduce using rule 60 (term -> factor termaux .)
    OR              reduce using rule 60 (term -> factor termaux .)
    LESSTHANEQUAL   reduce using rule 60 (term -> factor termaux .)
    GREATTHANEQUAL  reduce using rule 60 (term -> factor termaux .)
    GREATTHAN       reduce using rule 60 (term -> factor termaux .)
    LESSTHAN        reduce using rule 60 (term -> factor termaux .)
    RGTPAREN        reduce using rule 60 (term -> factor termaux .)
    SEMICOLON       reduce using rule 60 (term -> factor termaux .)
    COMMA           reduce using rule 60 (term -> factor termaux .)
    RGTBRACSQR      reduce using rule 60 (term -> factor termaux .)
    MULTIPLICATION  reduce using rule 60 (term -> factor termaux .)
    DIVISION        reduce using rule 60 (term -> factor termaux .)


state 123

    (63) termaux -> empty .

    PLUS            reduce using rule 63 (termaux -> empty .)
    MINUS           reduce using rule 63 (termaux -> empty .)
    AND             reduce using rule 63 (termaux -> empty .)
    DOUBEQUAL       reduce using rule 63 (termaux -> empty .)
    NOT             reduce using rule 63 (termaux -> empty .)
    OR              reduce using rule 63 (termaux -> empty .)
    LESSTHANEQUAL   reduce using rule 63 (termaux -> empty .)
    GREATTHANEQUAL  reduce using rule 63 (termaux -> empty .)
    GREATTHAN       reduce using rule 63 (termaux -> empty .)
    LESSTHAN        reduce using rule 63 (termaux -> empty .)
    RGTPAREN        reduce using rule 63 (termaux -> empty .)
    SEMICOLON       reduce using rule 63 (termaux -> empty .)
    COMMA           reduce using rule 63 (termaux -> empty .)
    RGTBRACSQR      reduce using rule 63 (termaux -> empty .)
    MULTIPLICATION  reduce using rule 63 (termaux -> empty .)
    DIVISION        reduce using rule 63 (termaux -> empty .)


state 124

    (40) factor -> factoraux constant .

    MULTIPLICATION  reduce using rule 40 (factor -> factoraux constant .)
    DIVISION        reduce using rule 40 (factor -> factoraux constant .)
    PLUS            reduce using rule 40 (factor -> factoraux constant .)
    MINUS           reduce using rule 40 (factor -> factoraux constant .)
    AND             reduce using rule 40 (factor -> factoraux constant .)
    DOUBEQUAL       reduce using rule 40 (factor -> factoraux constant .)
    NOT             reduce using rule 40 (factor -> factoraux constant .)
    OR              reduce using rule 40 (factor -> factoraux constant .)
    LESSTHANEQUAL   reduce using rule 40 (factor -> factoraux constant .)
    GREATTHANEQUAL  reduce using rule 40 (factor -> factoraux constant .)
    GREATTHAN       reduce using rule 40 (factor -> factoraux constant .)
    LESSTHAN        reduce using rule 40 (factor -> factoraux constant .)
    RGTPAREN        reduce using rule 40 (factor -> factoraux constant .)
    SEMICOLON       reduce using rule 40 (factor -> factoraux constant .)
    COMMA           reduce using rule 40 (factor -> factoraux constant .)
    RGTBRACSQR      reduce using rule 40 (factor -> factoraux constant .)


state 125

    (55) loop -> WHILE LFTPAREN expression RGTPAREN . block
    (19) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 149

state 126

    (56) write -> PRINT LFTPAREN constant RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 150


state 127

    (12) assignment -> assignmentaux EQUAL call SEMICOLON .

    IF              reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    WHILE           reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    PRINT           reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    READ            reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    ID              reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    INT             reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    FLOAT           reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    CHAR            reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    BOOL            reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    STRING          reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    RGTBRAC         reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)
    RETURN          reduce using rule 12 (assignment -> assignmentaux EQUAL call SEMICOLON .)


state 128

    (11) assignment -> assignmentaux EQUAL expression SEMICOLON .

    IF              reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    WHILE           reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    PRINT           reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    READ            reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    ID              reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    INT             reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    FLOAT           reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    CHAR            reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    STRING          reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    RGTBRAC         reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)
    RETURN          reduce using rule 11 (assignment -> assignmentaux EQUAL expression SEMICOLON .)


state 129

    (90) call -> ID LFTPAREN exp RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 151


state 130

    (91) call -> ID LFTPAREN exp COMMA . call RGTPAREN SEMICOLON
    (90) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON

    ID              shift and go to state 95

    call                           shift and go to state 152

state 131

    (5) array -> ID LFTBRACSQR exp RGTBRACSQR .

    EQUAL           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    COMMA           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    SEMICOLON       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    RGTPAREN        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    MULTIPLICATION  reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    DIVISION        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    PLUS            reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    MINUS           reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    AND             reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    DOUBEQUAL       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    NOT             reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    OR              reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    LESSTHANEQUAL   reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    GREATTHANEQUAL  reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    GREATTHAN       reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    LESSTHAN        reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)
    RGTBRACSQR      reduce using rule 5 (array -> ID LFTBRACSQR exp RGTBRACSQR .)


state 132

    (24) conditionaux -> LFTPAREN expression RGTPAREN . block ELSEIF conditionaux
    (25) conditionaux -> LFTPAREN expression RGTPAREN . block
    (19) block -> . LFTBRAC blockaux RGTBRAC

    LFTBRAC         shift and go to state 26

    block                          shift and go to state 153

state 133

    (23) condition -> IF conditionaux ELSE block .

    IF              reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    WHILE           reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    PRINT           reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    READ            reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    ID              reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    INT             reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    FLOAT           reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    CHAR            reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    BOOL            reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    STRING          reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    RGTBRAC         reduce using rule 23 (condition -> IF conditionaux ELSE block .)
    RETURN          reduce using rule 23 (condition -> IF conditionaux ELSE block .)


state 134

    (6) arrayvalues -> LFTBRACSQR . arrayvaluesaux RGTBRACSQR
    (7) arrayvaluesaux -> . cteN arrayvaluesaux2
    (8) arrayvaluesaux -> . cteS arrayvaluesaux2
    (32) cteN -> . FLOAT
    (33) cteN -> . INT
    (34) cteS -> . STRING

    FLOAT           shift and go to state 75
    INT             shift and go to state 73
    STRING          shift and go to state 72

    cteS                           shift and go to state 154
    cteN                           shift and go to state 155
    arrayvaluesaux                 shift and go to state 156

state 135

    (88) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues .
    (89) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues . COMMA varsaux2

    SEMICOLON       reduce using rule 88 (varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues .)
    COMMA           shift and go to state 157


state 136

    (87) varsaux2 -> ID EQUAL varsaux constant COMMA varsaux2 .

    SEMICOLON       reduce using rule 87 (varsaux2 -> ID EQUAL varsaux constant COMMA varsaux2 .)


state 137

    (58) parameter -> type ID COMMA parameter .

    RGTPAREN        reduce using rule 58 (parameter -> type ID COMMA parameter .)


state 138

    (59) parameter -> empty .

    RGTPAREN        reduce using rule 59 (parameter -> empty .)


state 139

    (17) blockreturnaux -> statement . blockreturnaux
    (17) blockreturnaux -> . statement blockreturnaux
    (18) blockreturnaux -> . empty
    (64) statement -> . assignment
    (65) statement -> . condition
    (66) statement -> . vars
    (67) statement -> . loop
    (68) statement -> . write
    (69) statement -> . read
    (70) statement -> . call
    (93) empty -> .
    (11) assignment -> . assignmentaux EQUAL expression SEMICOLON
    (12) assignment -> . assignmentaux EQUAL call SEMICOLON
    (22) condition -> . IF conditionaux
    (23) condition -> . IF conditionaux ELSE block
    (82) vars -> . type varsaux2 SEMICOLON
    (55) loop -> . WHILE LFTPAREN expression RGTPAREN block
    (56) write -> . PRINT LFTPAREN constant RGTPAREN SEMICOLON
    (92) read -> . READ LFTPAREN ID RGTPAREN SEMICOLON
    (90) call -> . ID LFTPAREN exp RGTPAREN SEMICOLON
    (91) call -> . ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON
    (13) assignmentaux -> . ID
    (14) assignmentaux -> . array
    (71) type -> . INT
    (72) type -> . FLOAT
    (73) type -> . CHAR
    (74) type -> . BOOL
    (75) type -> . STRING
    (5) array -> . ID LFTBRACSQR exp RGTBRACSQR

    RGTBRAC         reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    IF              shift and go to state 48
    WHILE           shift and go to state 35
    PRINT           shift and go to state 36
    READ            shift and go to state 34
    ID              shift and go to state 46
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 7
    BOOL            shift and go to state 15
    STRING          shift and go to state 12

    loop                           shift and go to state 49
    type                           shift and go to state 9
    vars                           shift and go to state 33
    read                           shift and go to state 39
    assignment                     shift and go to state 44
    write                          shift and go to state 38
    assignmentaux                  shift and go to state 45
    call                           shift and go to state 40
    empty                          shift and go to state 141
    statement                      shift and go to state 139
    blockreturnaux                 shift and go to state 158
    array                          shift and go to state 37
    condition                      shift and go to state 47

state 140

    (15) blockreturn -> LFTBRAC blockreturnaux . RGTBRAC
    (16) blockreturn -> LFTBRAC blockreturnaux . RETURN exp SEMICOLON RGTBRAC

    RGTBRAC         shift and go to state 160
    RETURN          shift and go to state 159


state 141

    (18) blockreturnaux -> empty .

    RGTBRAC         reduce using rule 18 (blockreturnaux -> empty .)
    RETURN          reduce using rule 18 (blockreturnaux -> empty .)


state 142

    (92) read -> READ LFTPAREN ID RGTPAREN SEMICOLON .

    IF              reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    READ            reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    ID              reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    INT             reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    STRING          reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 92 (read -> READ LFTPAREN ID RGTPAREN SEMICOLON .)


state 143

    (37) expaux -> PLUS exp . expaux
    (37) expaux -> . PLUS exp expaux
    (38) expaux -> . MINUS exp expaux
    (39) expaux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    AND             reduce using rule 93 (empty -> .)
    DOUBEQUAL       reduce using rule 93 (empty -> .)
    NOT             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    LESSTHANEQUAL   reduce using rule 93 (empty -> .)
    GREATTHANEQUAL  reduce using rule 93 (empty -> .)
    GREATTHAN       reduce using rule 93 (empty -> .)
    LESSTHAN        reduce using rule 93 (empty -> .)
    RGTPAREN        reduce using rule 93 (empty -> .)
    SEMICOLON       reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RGTBRACSQR      reduce using rule 93 (empty -> .)

  ! PLUS            [ reduce using rule 93 (empty -> .) ]
  ! MINUS           [ reduce using rule 93 (empty -> .) ]

    expaux                         shift and go to state 161
    empty                          shift and go to state 109

state 144

    (38) expaux -> MINUS exp . expaux
    (37) expaux -> . PLUS exp expaux
    (38) expaux -> . MINUS exp expaux
    (39) expaux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    AND             reduce using rule 93 (empty -> .)
    DOUBEQUAL       reduce using rule 93 (empty -> .)
    NOT             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    LESSTHANEQUAL   reduce using rule 93 (empty -> .)
    GREATTHANEQUAL  reduce using rule 93 (empty -> .)
    GREATTHAN       reduce using rule 93 (empty -> .)
    LESSTHAN        reduce using rule 93 (empty -> .)
    RGTPAREN        reduce using rule 93 (empty -> .)
    SEMICOLON       reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RGTBRACSQR      reduce using rule 93 (empty -> .)

  ! PLUS            [ reduce using rule 93 (empty -> .) ]
  ! MINUS           [ reduce using rule 93 (empty -> .) ]

    expaux                         shift and go to state 162
    empty                          shift and go to state 109

state 145

    (41) factor -> LFTPAREN expression RGTPAREN .

    MULTIPLICATION  reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    DIVISION        reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    PLUS            reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    MINUS           reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    AND             reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    DOUBEQUAL       reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    NOT             reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    OR              reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    LESSTHANEQUAL   reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    GREATTHANEQUAL  reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    GREATTHAN       reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    LESSTHAN        reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    RGTPAREN        reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    SEMICOLON       reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    COMMA           reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)
    RGTBRACSQR      reduce using rule 41 (factor -> LFTPAREN expression RGTPAREN .)


state 146

    (46) expression -> exp expressionaux exp .

    RGTPAREN        reduce using rule 46 (expression -> exp expressionaux exp .)
    SEMICOLON       reduce using rule 46 (expression -> exp expressionaux exp .)


state 147

    (62) termaux -> DIVISION term . termaux
    (61) termaux -> . MULTIPLICATION term termaux
    (62) termaux -> . DIVISION term termaux
    (63) termaux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 121
    DIVISION        shift and go to state 120
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    DOUBEQUAL       reduce using rule 93 (empty -> .)
    NOT             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    LESSTHANEQUAL   reduce using rule 93 (empty -> .)
    GREATTHANEQUAL  reduce using rule 93 (empty -> .)
    GREATTHAN       reduce using rule 93 (empty -> .)
    LESSTHAN        reduce using rule 93 (empty -> .)
    RGTPAREN        reduce using rule 93 (empty -> .)
    SEMICOLON       reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RGTBRACSQR      reduce using rule 93 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 93 (empty -> .) ]
  ! DIVISION        [ reduce using rule 93 (empty -> .) ]

    termaux                        shift and go to state 163
    empty                          shift and go to state 123

state 148

    (61) termaux -> MULTIPLICATION term . termaux
    (61) termaux -> . MULTIPLICATION term termaux
    (62) termaux -> . DIVISION term termaux
    (63) termaux -> . empty
    (93) empty -> .

  ! shift/reduce conflict for MULTIPLICATION resolved as shift
  ! shift/reduce conflict for DIVISION resolved as shift
    MULTIPLICATION  shift and go to state 121
    DIVISION        shift and go to state 120
    PLUS            reduce using rule 93 (empty -> .)
    MINUS           reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    DOUBEQUAL       reduce using rule 93 (empty -> .)
    NOT             reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    LESSTHANEQUAL   reduce using rule 93 (empty -> .)
    GREATTHANEQUAL  reduce using rule 93 (empty -> .)
    GREATTHAN       reduce using rule 93 (empty -> .)
    LESSTHAN        reduce using rule 93 (empty -> .)
    RGTPAREN        reduce using rule 93 (empty -> .)
    SEMICOLON       reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RGTBRACSQR      reduce using rule 93 (empty -> .)

  ! MULTIPLICATION  [ reduce using rule 93 (empty -> .) ]
  ! DIVISION        [ reduce using rule 93 (empty -> .) ]

    termaux                        shift and go to state 164
    empty                          shift and go to state 123

state 149

    (55) loop -> WHILE LFTPAREN expression RGTPAREN block .

    IF              reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    WHILE           reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    PRINT           reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    READ            reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    ID              reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    INT             reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    FLOAT           reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    CHAR            reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    BOOL            reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    STRING          reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    RGTBRAC         reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)
    RETURN          reduce using rule 55 (loop -> WHILE LFTPAREN expression RGTPAREN block .)


state 150

    (56) write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .

    IF              reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    READ            reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    ID              reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    INT             reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    STRING          reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 56 (write -> PRINT LFTPAREN constant RGTPAREN SEMICOLON .)


state 151

    (90) call -> ID LFTPAREN exp RGTPAREN SEMICOLON .

    RGTPAREN        reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    IF              reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    READ            reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    ID              reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    INT             reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    STRING          reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 90 (call -> ID LFTPAREN exp RGTPAREN SEMICOLON .)


state 152

    (91) call -> ID LFTPAREN exp COMMA call . RGTPAREN SEMICOLON

    RGTPAREN        shift and go to state 165


state 153

    (24) conditionaux -> LFTPAREN expression RGTPAREN block . ELSEIF conditionaux
    (25) conditionaux -> LFTPAREN expression RGTPAREN block .

    ELSEIF          shift and go to state 166
    ELSE            reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    IF              reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    WHILE           reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    PRINT           reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    READ            reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    ID              reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    INT             reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    FLOAT           reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    CHAR            reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    BOOL            reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    STRING          reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    RGTBRAC         reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)
    RETURN          reduce using rule 25 (conditionaux -> LFTPAREN expression RGTPAREN block .)


state 154

    (8) arrayvaluesaux -> cteS . arrayvaluesaux2
    (9) arrayvaluesaux2 -> . COMMA arrayvaluesaux
    (10) arrayvaluesaux2 -> . empty
    (93) empty -> .

    COMMA           shift and go to state 167
    RGTBRACSQR      reduce using rule 93 (empty -> .)

    empty                          shift and go to state 168
    arrayvaluesaux2                shift and go to state 169

state 155

    (7) arrayvaluesaux -> cteN . arrayvaluesaux2
    (9) arrayvaluesaux2 -> . COMMA arrayvaluesaux
    (10) arrayvaluesaux2 -> . empty
    (93) empty -> .

    COMMA           shift and go to state 167
    RGTBRACSQR      reduce using rule 93 (empty -> .)

    empty                          shift and go to state 168
    arrayvaluesaux2                shift and go to state 170

state 156

    (6) arrayvalues -> LFTBRACSQR arrayvaluesaux . RGTBRACSQR

    RGTBRACSQR      shift and go to state 171


state 157

    (89) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA . varsaux2
    (86) varsaux2 -> . ID EQUAL varsaux constant
    (87) varsaux2 -> . ID EQUAL varsaux constant COMMA varsaux2
    (88) varsaux2 -> . ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues
    (89) varsaux2 -> . ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2

    ID              shift and go to state 23

    varsaux2                       shift and go to state 172

state 158

    (17) blockreturnaux -> statement blockreturnaux .

    RGTBRAC         reduce using rule 17 (blockreturnaux -> statement blockreturnaux .)
    RETURN          reduce using rule 17 (blockreturnaux -> statement blockreturnaux .)


state 159

    (16) blockreturn -> LFTBRAC blockreturnaux RETURN . exp SEMICOLON RGTBRAC
    (35) exp -> . term
    (36) exp -> . term expaux
    (60) term -> . factor termaux
    (40) factor -> . factoraux constant
    (41) factor -> . LFTPAREN expression RGTPAREN
    (42) factoraux -> . PLUS
    (43) factoraux -> . MINUS
    (44) factoraux -> . empty
    (93) empty -> .

    LFTPAREN        shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 91
    ID              reduce using rule 93 (empty -> .)
    TRUE            reduce using rule 93 (empty -> .)
    FALSE           reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    STRING          reduce using rule 93 (empty -> .)

    term                           shift and go to state 83
    exp                            shift and go to state 173
    factor                         shift and go to state 88
    factoraux                      shift and go to state 89
    empty                          shift and go to state 86

state 160

    (15) blockreturn -> LFTBRAC blockreturnaux RGTBRAC .

    FUNCTION        reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    INT             reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    FLOAT           reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    CHAR            reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    BOOL            reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    STRING          reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)
    PRIOMH          reduce using rule 15 (blockreturn -> LFTBRAC blockreturnaux RGTBRAC .)


state 161

    (37) expaux -> PLUS exp expaux .

    AND             reduce using rule 37 (expaux -> PLUS exp expaux .)
    DOUBEQUAL       reduce using rule 37 (expaux -> PLUS exp expaux .)
    NOT             reduce using rule 37 (expaux -> PLUS exp expaux .)
    OR              reduce using rule 37 (expaux -> PLUS exp expaux .)
    LESSTHANEQUAL   reduce using rule 37 (expaux -> PLUS exp expaux .)
    GREATTHANEQUAL  reduce using rule 37 (expaux -> PLUS exp expaux .)
    GREATTHAN       reduce using rule 37 (expaux -> PLUS exp expaux .)
    LESSTHAN        reduce using rule 37 (expaux -> PLUS exp expaux .)
    RGTPAREN        reduce using rule 37 (expaux -> PLUS exp expaux .)
    SEMICOLON       reduce using rule 37 (expaux -> PLUS exp expaux .)
    COMMA           reduce using rule 37 (expaux -> PLUS exp expaux .)
    RGTBRACSQR      reduce using rule 37 (expaux -> PLUS exp expaux .)
    PLUS            reduce using rule 37 (expaux -> PLUS exp expaux .)
    MINUS           reduce using rule 37 (expaux -> PLUS exp expaux .)


state 162

    (38) expaux -> MINUS exp expaux .

    AND             reduce using rule 38 (expaux -> MINUS exp expaux .)
    DOUBEQUAL       reduce using rule 38 (expaux -> MINUS exp expaux .)
    NOT             reduce using rule 38 (expaux -> MINUS exp expaux .)
    OR              reduce using rule 38 (expaux -> MINUS exp expaux .)
    LESSTHANEQUAL   reduce using rule 38 (expaux -> MINUS exp expaux .)
    GREATTHANEQUAL  reduce using rule 38 (expaux -> MINUS exp expaux .)
    GREATTHAN       reduce using rule 38 (expaux -> MINUS exp expaux .)
    LESSTHAN        reduce using rule 38 (expaux -> MINUS exp expaux .)
    RGTPAREN        reduce using rule 38 (expaux -> MINUS exp expaux .)
    SEMICOLON       reduce using rule 38 (expaux -> MINUS exp expaux .)
    COMMA           reduce using rule 38 (expaux -> MINUS exp expaux .)
    RGTBRACSQR      reduce using rule 38 (expaux -> MINUS exp expaux .)
    PLUS            reduce using rule 38 (expaux -> MINUS exp expaux .)
    MINUS           reduce using rule 38 (expaux -> MINUS exp expaux .)


state 163

    (62) termaux -> DIVISION term termaux .

    PLUS            reduce using rule 62 (termaux -> DIVISION term termaux .)
    MINUS           reduce using rule 62 (termaux -> DIVISION term termaux .)
    AND             reduce using rule 62 (termaux -> DIVISION term termaux .)
    DOUBEQUAL       reduce using rule 62 (termaux -> DIVISION term termaux .)
    NOT             reduce using rule 62 (termaux -> DIVISION term termaux .)
    OR              reduce using rule 62 (termaux -> DIVISION term termaux .)
    LESSTHANEQUAL   reduce using rule 62 (termaux -> DIVISION term termaux .)
    GREATTHANEQUAL  reduce using rule 62 (termaux -> DIVISION term termaux .)
    GREATTHAN       reduce using rule 62 (termaux -> DIVISION term termaux .)
    LESSTHAN        reduce using rule 62 (termaux -> DIVISION term termaux .)
    RGTPAREN        reduce using rule 62 (termaux -> DIVISION term termaux .)
    SEMICOLON       reduce using rule 62 (termaux -> DIVISION term termaux .)
    COMMA           reduce using rule 62 (termaux -> DIVISION term termaux .)
    RGTBRACSQR      reduce using rule 62 (termaux -> DIVISION term termaux .)
    MULTIPLICATION  reduce using rule 62 (termaux -> DIVISION term termaux .)
    DIVISION        reduce using rule 62 (termaux -> DIVISION term termaux .)


state 164

    (61) termaux -> MULTIPLICATION term termaux .

    PLUS            reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    MINUS           reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    AND             reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    DOUBEQUAL       reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    NOT             reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    OR              reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    LESSTHANEQUAL   reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    GREATTHANEQUAL  reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    GREATTHAN       reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    LESSTHAN        reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    RGTPAREN        reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    SEMICOLON       reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    COMMA           reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    RGTBRACSQR      reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    MULTIPLICATION  reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)
    DIVISION        reduce using rule 61 (termaux -> MULTIPLICATION term termaux .)


state 165

    (91) call -> ID LFTPAREN exp COMMA call RGTPAREN . SEMICOLON

    SEMICOLON       shift and go to state 174


state 166

    (24) conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF . conditionaux
    (24) conditionaux -> . LFTPAREN expression RGTPAREN block ELSEIF conditionaux
    (25) conditionaux -> . LFTPAREN expression RGTPAREN block

    LFTPAREN        shift and go to state 67

    conditionaux                   shift and go to state 175

state 167

    (9) arrayvaluesaux2 -> COMMA . arrayvaluesaux
    (7) arrayvaluesaux -> . cteN arrayvaluesaux2
    (8) arrayvaluesaux -> . cteS arrayvaluesaux2
    (32) cteN -> . FLOAT
    (33) cteN -> . INT
    (34) cteS -> . STRING

    FLOAT           shift and go to state 75
    INT             shift and go to state 73
    STRING          shift and go to state 72

    cteS                           shift and go to state 154
    cteN                           shift and go to state 155
    arrayvaluesaux                 shift and go to state 176

state 168

    (10) arrayvaluesaux2 -> empty .

    RGTBRACSQR      reduce using rule 10 (arrayvaluesaux2 -> empty .)


state 169

    (8) arrayvaluesaux -> cteS arrayvaluesaux2 .

    RGTBRACSQR      reduce using rule 8 (arrayvaluesaux -> cteS arrayvaluesaux2 .)


state 170

    (7) arrayvaluesaux -> cteN arrayvaluesaux2 .

    RGTBRACSQR      reduce using rule 7 (arrayvaluesaux -> cteN arrayvaluesaux2 .)


state 171

    (6) arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR .

    COMMA           reduce using rule 6 (arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR .)
    SEMICOLON       reduce using rule 6 (arrayvalues -> LFTBRACSQR arrayvaluesaux RGTBRACSQR .)


state 172

    (89) varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2 .

    SEMICOLON       reduce using rule 89 (varsaux2 -> ID LFTBRACSQR INT RGTBRACSQR EQUAL arrayvalues COMMA varsaux2 .)


state 173

    (16) blockreturn -> LFTBRAC blockreturnaux RETURN exp . SEMICOLON RGTBRAC

    SEMICOLON       shift and go to state 177


state 174

    (91) call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .

    RGTPAREN        reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    IF              reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    WHILE           reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    PRINT           reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    READ            reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    ID              reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    INT             reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    FLOAT           reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    CHAR            reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    BOOL            reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    STRING          reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    RGTBRAC         reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    RETURN          reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 91 (call -> ID LFTPAREN exp COMMA call RGTPAREN SEMICOLON .)


state 175

    (24) conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .

    ELSE            reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    IF              reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    WHILE           reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    PRINT           reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    READ            reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    ID              reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    INT             reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    FLOAT           reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    CHAR            reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    BOOL            reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    STRING          reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    RGTBRAC         reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)
    RETURN          reduce using rule 24 (conditionaux -> LFTPAREN expression RGTPAREN block ELSEIF conditionaux .)


state 176

    (9) arrayvaluesaux2 -> COMMA arrayvaluesaux .

    RGTBRACSQR      reduce using rule 9 (arrayvaluesaux2 -> COMMA arrayvaluesaux .)


state 177

    (16) blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON . RGTBRAC

    RGTBRAC         shift and go to state 178


state 178

    (16) blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .

    FUNCTION        reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    INT             reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    FLOAT           reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    CHAR            reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    BOOL            reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    STRING          reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)
    PRIOMH          reduce using rule 16 (blockreturn -> LFTBRAC blockreturnaux RETURN exp SEMICOLON RGTBRAC .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 144 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 144 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 147 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 147 resolved as shift
WARNING: shift/reduce conflict for MULTIPLICATION in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVISION in state 148 resolved as shift
WARNING: reduce/reduce conflict in state 58 resolved using rule (parameter -> empty)
WARNING: rejected rule (functionaux2 -> empty) in state 58
WARNING: reduce/reduce conflict in state 83 resolved using rule (exp -> term)
WARNING: rejected rule (empty -> <empty>) in state 83
WARNING: Rule (functionaux2 -> empty) is never reduced
